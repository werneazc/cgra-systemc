<?xml version="1.0" ?>
<component id="root" name="root">
	<component id="system" name="system">
		<!--McPAT will skip the components if number is set to 0 -->
		<!--Duty cycles in this file are set according to "ARM MPcore
			ARchitecture performance Enhancement" in MPF Japan 2008 -->
		<param name="number_of_cores" value="18"/>
		<param name="number_of_L1Directories" value="0"/>
		<param name="number_of_L2Directories" value="0"/>
		<param name="number_of_L2s" value="0"/> <!-- This number means how many L2 clusters in each cluster there can be multiple banks/ports -->
		<param name="Private_L2" value="0"/><!--1 Private, 0 shared/coherent -->
		<param name="number_of_L3s" value="1"/> <!-- This number means how many L3 clusters -->
		<param name="number_of_NoCs" value="4"/>
		<param name="homogeneous_cores" value="0"/><!--1 means homo -->
		<param name="homogeneous_L2s" value="0"/>
		<param name="homogeneous_L1Directories" value="0"/>
		<param name="homogeneous_L2Directories" value="0"/>
		<param name="homogeneous_L3s" value="0"/>
		<param name="homogeneous_ccs" value="0"/><!--cache coherence hardware -->
		<param name="homogeneous_NoCs" value="0"/>
		<param name="core_tech_node" value="40"/><!-- nm -->
		<param name="target_core_clockrate" value="5"/><!--MHz -->
		<param name="temperature" value="340"/> <!-- Kelvin -->
		<param name="number_cache_levels" value="0"/>
		<param name="interconnect_projection_type" value="0"/><!--0: aggressive wire technology; 1: conservative wire technology -->
		<param name="device_type" value="0"/><!--0: HP(High Performance Type); 1: LSTP(Low standby power) 2: LOP (Low Operating Power)  -->
		<param name="longer_channel_device" value="0"/><!-- 0 no use; 1 use when possible -->
		<param name="Embedded" value="1"/><!-- Embedded processor like ARM or general purpose processors?  -->
		<param name="opt_clockrate" value="1"/>
		<param name="machine_bits" value="16"/>
		<param name="virtual_address_width" value="16"/>
		<param name="physical_address_width" value="16"/>
		<param name="virtual_memory_page_size" value="8"/>
		<!-- address width determines the tag_width in Cache, LSQ and buffers in cache controller 
			default value is machine_bits, if not set --> 
		<stat name="total_cycles" value="2660805"/>
		<stat name="idle_cycles" value="0"/>
		<stat name="busy_cycles"  value="2660805"/>
			<!--This page size(B) is complete different from the page size in Main memo section. this page size is the size of 
			virtual memory from OS/Archi perspective; the page size in Main memo section is the actual physical line in a DRAM bank  -->
		<!-- *********************** SyncUnit ***************** -->
		<component id="system.core0" name="core0">
			<!-- Core property -->
			<param name="clock_rate" value="5"/>
			<!-- for cores with unknown timing, set to 0 to force off the opt flag -->
			<param name="opt_local" value="0"/>
			<param name="instruction_length" value="32"/>
			<param name="opcode_width" value="7"/>
			<param name="x86" value="0"/>
			<param name="micro_opcode_width" value="0"/>
			<param name="machine_type" value="1"/>
			<!-- inorder/OoO; 1 inorder; 0 OOO-->
			<param name="number_hardware_threads" value="1"/>
			<!-- number_instruction_fetch_ports(icache ports) is always 1 in single-thread processor,
			it only may be more than one in SMT processors. BTB ports always equals to fetch ports since 
			branch information in consecutive branch instructions in the same fetch group can be read out from BTB once.--> 
			<param name="fetch_width" value="0"/>
			<!-- fetch_width determines the size of cachelines of L1 cache block -->
			<param name="number_instruction_fetch_ports" value="0"/>
			<param name="decode_width" value="0"/>
			<!-- decode_width determines the number of ports of the 
			renaming table (both RAM and CAM) scheme -->
			<param name="issue_width" value="0"/>
			<param name="peak_issue_width" value="0"/>
			<!-- issue_width determines the number of ports of Issue window and other logic 
			as in the complexity effective processors paper; issue_width==dispatch_width -->
			<param name="commit_width" value="0"/>
			<!-- commit_width determines the number of ports of register files -->
			<param name="fp_issue_width" value="0"/>
			<param name="prediction_width" value="0"/> 
			<!-- number of branch instructions can be predicted simultaneously-->
			<!-- Current version of McPAT does not distinguish int and floating point pipelines 
			Theses parameters are reserved for future use.--> 
			<param name="pipelines_per_core" value="1,0"/>
			<!--integer_pipeline and floating_pipelines, if the floating_pipelines is 0, then the pipeline is shared-->
			<param name="pipeline_depth" value="0,0"/>
			<!-- pipeline depth of int and fp, if pipeline is shared, the second number is the average cycles of fp ops -->
			<!-- issue and exe unit-->
			<param name="ALU_per_core" value="1"/>
			<!-- contains an adder, a shifter, and a logical unit -->
			<param name="MUL_per_core" value="0"/>
			<!-- For MUL and Div -->
			<param name="FPU_per_core" value="0"/>		
			<!-- buffer between IF and ID stage -->
			<param name="instruction_buffer_size" value="0"/>
			<!-- buffer between ID and sche/exe stage -->
			<param name="decoded_stream_buffer_size" value="0"/>
			<param name="instruction_window_scheme" value="0"/><!-- 0 PHYREG based, 1 RSBASED-->
			<!-- McPAT support 2 types of OoO cores, RS based and physical reg based-->
			<param name="instruction_window_size" value="0"/>
			<param name="fp_instruction_window_size" value="0"/>
			<!-- Numbers need to be confirmed -->
			<!-- the instruction issue Q as in Alpha 21264; The RS as in Intel P6 -->
			<param name="ROB_size" value="0"/>
			<!-- each in-flight instruction has an entry in ROB -->
			<!-- registers -->
			<param name="archi_Regs_IRF_size" value="16"/>			
			<param name="archi_Regs_FRF_size" value="0"/>
			<!--  if OoO processor, phy_reg number is needed for renaming logic, 
			renaming logic is for both integer and floating point insts.  -->
			<param name="phy_Regs_IRF_size" value="0"/>
			<param name="phy_Regs_FRF_size" value="0"/>
			<!-- rename logic -->
			<param name="rename_scheme" value="0"/>
			<!-- can be RAM based(0) or CAM based(1) rename scheme 
			RAM-based scheme will have free list, status table;
			CAM-based scheme have the valid bit in the data field of the CAM -->
			<param name="checkpoint_depth" value="0"/>
			<!-- RAM and CAM RAT contains checkpoints, checkpoint_depth=# of in_flight speculations;
			RAM-based RAT should not have more than 4 GCs (e.g., MIPS R10000). 
			McPAT assumes the exsistance of RRAT when the RAM-RAT having no GCs (e.g., Netburst)
			CAM-based RAT should have at least 1 GC and can have more than 8 GCs. -->
			<param name="register_windows_size" value="0"/>
			<!-- how many windows in the windowed register file, sun processors;
			no register windowing is used when this number is 0 -->
			<!-- In OoO cores, loads and stores can be issued whether inorder(Pentium Pro) or (OoO)out-of-order(Alpha),
			They will always try to execute out-of-order though. -->
			<param name="LSU_order" value="inorder"/>
			<param name="store_buffer_size" value="0"/>
			<!-- By default, in-order cores do not have load buffers -->
			<param name="load_buffer_size" value="0"/>	
			<!-- number of ports refer to sustain-able concurrent memory accesses --> 
			<param name="memory_ports" value="0"/>	
			<!-- max_allowed_in_flight_memo_instructions determines the # of ports of load and store buffer
			as well as the ports of Dcache which is connected to LSU -->	
			<!-- dual-pumped Dcache can be used to save the extra read/write ports -->
			<param name="RAS_size" value="0"/>						
			<!-- general stats, defines simulation periods;require total, idle, and busy cycles for sanity check  -->
			<!-- please note: if target architecture is X86, then all the instructions refer to (fused) micro-ops -->
			<stat name="total_instructions" value="2660805"/>
			<stat name="int_instructions" value="0"/>
			<stat name="fp_instructions" value="0"/>
			<stat name="branch_instructions" value="0"/>
			<stat name="branch_mispredictions" value="0"/>
			<stat name="load_instructions" value="0"/>
			<stat name="store_instructions" value="2660805"/>
			<stat name="committed_instructions" value="0"/>
			<stat name="committed_int_instructions" value="0"/>
			<stat name="committed_fp_instructions" value="0"/>
			<stat name="pipeline_duty_cycle" value="1"/><!--<=1, runtime_ipc/peak_ipc; averaged for all cores if homogeneous -->
			<!-- the following cycle stats are used for heterogeneous cores only, 
				please ignore them if homogeneous cores -->
			<stat name="total_cycles" value="2660805"/>
			<stat name="idle_cycles" value="0"/>
			<stat name="busy_cycles"  value="2660805"/>
			<!-- instruction buffer stats -->
			<!-- ROB stats, both RS and Phy based OoOs have ROB
			performance simulator should capture the difference on accesses,
			otherwise, McPAT has to guess based on number of committed instructions. -->
			<stat name="ROB_reads" value="0"/>
			<stat name="ROB_writes" value="0"/>
			<!-- RAT accesses -->
			<stat name="rename_reads" value="0"/> <!--lookup in renaming logic -->
			<stat name="rename_writes" value="0"/><!--update dest regs. renaming logic -->
			<stat name="fp_rename_reads" value="0"/>
			<stat name="fp_rename_writes" value="0"/>
			<!-- decode and rename stage use this, should be total ic - nop -->
			<!-- Inst window stats -->
			<stat name="inst_window_reads" value="0"/>
			<stat name="inst_window_writes" value="0"/>
			<stat name="inst_window_wakeup_accesses" value="0"/>
			<stat name="fp_inst_window_reads" value="0"/>
			<stat name="fp_inst_window_writes" value="0"/>
			<stat name="fp_inst_window_wakeup_accesses" value="0"/>
			<!--  RF accesses -->
			<stat name="int_regfile_reads" value="0"/>
			<stat name="float_regfile_reads" value="0"/>
			<stat name="int_regfile_writes" value="0"/>
			<stat name="float_regfile_writes" value="0"/>
			<!-- accesses to the working reg -->
			<stat name="function_calls" value="0"/>
			<stat name="context_switches" value="0"/>
			<!-- Number of Windows switches (number of function calls and returns)-->
			<!-- Alu stats by default, the processor has one FPU that includes the divider and 
			 multiplier. The fpu accesses should include accesses to multiplier and divider  -->
			<stat name="ialu_accesses" value="2660805"/>			
			<stat name="fpu_accesses" value="0"/>
			<stat name="mul_accesses" value="0"/>
			<stat name="cdb_alu_accesses" value="0"/>
			<stat name="cdb_mul_accesses" value="0"/>
			<stat name="cdb_fpu_accesses" value="0"/>
			<!-- multiple cycle accesses should be counted multiple times, 
			otherwise, McPAT can use internal counter for different floating point instructions 
			to get final accesses. But that needs detailed info for floating point inst mix -->
			<!--  currently the performance simulator should 
			make sure all the numbers are final numbers, 
			including the explicit read/write accesses, 
			and the implicit accesses such as replacements and etc.
			Future versions of McPAT may be able to reason the implicit access
			based on param and stats of last level cache
			The same rule applies to all cache access stats too!  -->
			<!-- following is AF for max power computation. 
				Do not change them, unless you understand them-->
			<stat name="IFU_duty_cycle" value="0.9"/>
			<stat name="BR_duty_cycle" value="0.72"/><!--branch-->			
			<stat name="LSU_duty_cycle" value="0.71"/>
			<stat name="MemManU_I_duty_cycle" value="0.9"/>
			<stat name="MemManU_D_duty_cycle" value="0.71"/>
			<stat name="ALU_duty_cycle" value="0.76"/>
			<!-- (.78*2+.71)/3 -->
			<stat name="MUL_duty_cycle" value="0.82"/>
			<stat name="FPU_duty_cycle" value="0.0"/>
			<stat name="ALU_cdb_duty_cycle" value="0.76"/>
			<stat name="MUL_cdb_duty_cycle" value="0.82"/>
			<stat name="FPU_cdb_duty_cycle" value="0.0"/>
		</component>
		<!-- *********************** Proc. Elem. ******************* -->
		<component id="system.core1" name="core1">
			<!-- Core property -->
			<param name="clock_rate" value="5"/>
			<!-- for cores with unknown timing, set to 0 to force off the opt flag -->
			<param name="opt_local" value="0"/>
			<param name="instruction_length" value="32"/>
			<param name="opcode_width" value="7"/>
			<param name="x86" value="0"/>
			<param name="micro_opcode_width" value="0"/>
			<param name="machine_type" value="1"/>
			<!-- inorder/OoO; 1 inorder; 0 OOO-->
			<param name="number_hardware_threads" value="1"/>
			<!-- number_instruction_fetch_ports(icache ports) is always 1 in single-thread processor,
			it only may be more than one in SMT processors. BTB ports always equals to fetch ports since 
			branch information in consecutive branch instructions in the same fetch group can be read out from BTB once.--> 
			<param name="fetch_width" value="0"/>
			<!-- fetch_width determines the size of cachelines of L1 cache block -->
			<param name="number_instruction_fetch_ports" value="0"/>
			<param name="decode_width" value="0"/>
			<!-- decode_width determines the number of ports of the 
			renaming table (both RAM and CAM) scheme -->
			<param name="issue_width" value="0"/>
			<param name="peak_issue_width" value="0"/>
			<!-- issue_width determines the number of ports of Issue window and other logic 
			as in the complexity effective processors paper; issue_width==dispatch_width -->
			<param name="commit_width" value="0"/>
			<!-- commit_width determines the number of ports of register files -->
			<param name="fp_issue_width" value="0"/>
			<param name="prediction_width" value="0"/> 
			<!-- number of branch instructions can be predicted simultaneously-->
			<!-- Current version of McPAT does not distinguish int and floating point pipelines 
			Theses parameters are reserved for future use.--> 
			<param name="pipelines_per_core" value="0,0"/>
			<!--integer_pipeline and floating_pipelines, if the floating_pipelines is 0, then the pipeline is shared-->
			<param name="pipeline_depth" value="0,0"/>
			<!-- pipeline depth of int and fp, if pipeline is shared, the second number is the average cycles of fp ops -->
			<!-- issue and exe unit-->
			<param name="ALU_per_core" value="1"/>
			<!-- contains an adder, a shifter, and a logical unit -->
			<param name="MUL_per_core" value="0"/>
			<!-- For MUL and Div -->
			<param name="FPU_per_core" value="0"/>		
			<!-- buffer between IF and ID stage -->
			<param name="instruction_buffer_size" value="0"/>
			<!-- buffer between ID and sche/exe stage -->
			<param name="decoded_stream_buffer_size" value="0"/>
			<param name="instruction_window_scheme" value="0"/><!-- 0 PHYREG based, 1 RSBASED-->
			<!-- McPAT support 2 types of OoO cores, RS based and physical reg based-->
			<param name="instruction_window_size" value="0"/>
			<param name="fp_instruction_window_size" value="0"/>
			<!-- Numbers need to be confirmed -->
			<!-- the instruction issue Q as in Alpha 21264; The RS as in Intel P6 -->
			<param name="ROB_size" value="0"/>
			<!-- each in-flight instruction has an entry in ROB -->
			<!-- registers -->
			<param name="archi_Regs_IRF_size" value="0"/>			
			<param name="archi_Regs_FRF_size" value="0"/>
			<!--  if OoO processor, phy_reg number is needed for renaming logic, 
			renaming logic is for both integer and floating point insts.  -->
			<param name="phy_Regs_IRF_size" value="0"/>
			<param name="phy_Regs_FRF_size" value="0"/>
			<!-- rename logic -->
			<param name="rename_scheme" value="0"/>
			<!-- can be RAM based(0) or CAM based(1) rename scheme 
			RAM-based scheme will have free list, status table;
			CAM-based scheme have the valid bit in the data field of the CAM -->
			<param name="checkpoint_depth" value="0"/>
			<!-- RAM and CAM RAT contains checkpoints, checkpoint_depth=# of in_flight speculations;
			RAM-based RAT should not have more than 4 GCs (e.g., MIPS R10000). 
			McPAT assumes the exsistance of RRAT when the RAM-RAT having no GCs (e.g., Netburst)
			CAM-based RAT should have at least 1 GC and can have more than 8 GCs. -->
			<param name="register_windows_size" value="0"/>
			<!-- how many windows in the windowed register file, sun processors;
			no register windowing is used when this number is 0 -->
			<!-- In OoO cores, loads and stores can be issued whether inorder(Pentium Pro) or (OoO)out-of-order(Alpha),
			They will always try to execute out-of-order though. -->
			<param name="LSU_order" value="inorder"/>
			<param name="store_buffer_size" value="0"/>
			<!-- By default, in-order cores do not have load buffers -->
			<param name="load_buffer_size" value="0"/>	
			<!-- number of ports refer to sustain-able concurrent memory accesses --> 
			<param name="memory_ports" value="0"/>	
			<!-- max_allowed_in_flight_memo_instructions determines the # of ports of load and store buffer
			as well as the ports of Dcache which is connected to LSU -->	
			<!-- dual-pumped Dcache can be used to save the extra read/write ports -->
			<param name="RAS_size" value="0"/>						
			<!-- general stats, defines simulation periods;require total, idle, and busy cycles for sanity check  -->
			<!-- please note: if target architecture is X86, then all the instructions refer to (fused) micro-ops -->
			<stat name="total_instructions" value="46128"/>
			<stat name="int_instructions" value="46128"/>
			<stat name="fp_instructions" value="0"/>
			<stat name="branch_instructions" value="0"/>
			<stat name="branch_mispredictions" value="0"/>
			<stat name="load_instructions" value="0"/>
			<stat name="store_instructions" value="0"/>
			<stat name="committed_instructions" value="0"/>
			<stat name="committed_int_instructions" value="0"/>
			<stat name="committed_fp_instructions" value="0"/>
			<stat name="pipeline_duty_cycle" value="1"/><!--<=1, runtime_ipc/peak_ipc; averaged for all cores if homogeneous -->
			<!-- the following cycle stats are used for heterogeneous cores only, 
				please ignore them if homogeneous cores -->
			<stat name="total_cycles" value="2660804"/>
			<stat name="idle_cycles" value="2614676"/>
			<stat name="busy_cycles"  value="46128"/>
			<!-- instruction buffer stats -->
			<!-- ROB stats, both RS and Phy based OoOs have ROB
			performance simulator should capture the difference on accesses,
			otherwise, McPAT has to guess based on number of committed instructions. -->
			<stat name="ROB_reads" value="0"/>
			<stat name="ROB_writes" value="0"/>
			<!-- RAT accesses -->
			<stat name="rename_reads" value="0"/> <!--lookup in renaming logic -->
			<stat name="rename_writes" value="0"/><!--update dest regs. renaming logic -->
			<stat name="fp_rename_reads" value="0"/>
			<stat name="fp_rename_writes" value="0"/>
			<!-- decode and rename stage use this, should be total ic - nop -->
			<!-- Inst window stats -->
			<stat name="inst_window_reads" value="0"/>
			<stat name="inst_window_writes" value="0"/>
			<stat name="inst_window_wakeup_accesses" value="0"/>
			<stat name="fp_inst_window_reads" value="0"/>
			<stat name="fp_inst_window_writes" value="0"/>
			<stat name="fp_inst_window_wakeup_accesses" value="0"/>
			<!--  RF accesses -->
			<stat name="int_regfile_reads" value="0"/>
			<stat name="float_regfile_reads" value="0"/>
			<stat name="int_regfile_writes" value="0"/>
			<stat name="float_regfile_writes" value="0"/>
			<!-- accesses to the working reg -->
			<stat name="function_calls" value="0"/>
			<stat name="context_switches" value="0"/>
			<!-- Number of Windows switches (number of function calls and returns)-->
			<!-- Alu stats by default, the processor has one FPU that includes the divider and 
			 multiplier. The fpu accesses should include accesses to multiplier and divider  -->
			<stat name="ialu_accesses" value="46128"/>			
			<stat name="fpu_accesses" value="0"/>
			<stat name="mul_accesses" value="0"/>
			<stat name="cdb_alu_accesses" value="0"/>
			<stat name="cdb_mul_accesses" value="0"/>
			<stat name="cdb_fpu_accesses" value="0"/>
			<!-- multiple cycle accesses should be counted multiple times, 
			otherwise, McPAT can use internal counter for different floating point instructions 
			to get final accesses. But that needs detailed info for floating point inst mix -->
			<!--  currently the performance simulator should 
			make sure all the numbers are final numbers, 
			including the explicit read/write accesses, 
			and the implicit accesses such as replacements and etc.
			Future versions of McPAT may be able to reason the implicit access
			based on param and stats of last level cache
			The same rule applies to all cache access stats too!  -->
			<!-- following is AF for max power computation. 
				Do not change them, unless you understand them-->
			<stat name="IFU_duty_cycle" value="0.9"/>
			<stat name="BR_duty_cycle" value="0.72"/><!--branch-->			
			<stat name="LSU_duty_cycle" value="0.71"/>
			<stat name="MemManU_I_duty_cycle" value="0.9"/>
			<stat name="MemManU_D_duty_cycle" value="0.71"/>
			<stat name="ALU_duty_cycle" value="0.76"/>
			<!-- (.78*2+.71)/3 -->
			<stat name="MUL_duty_cycle" value="0.82"/>
			<stat name="FPU_duty_cycle" value="0.0"/>
			<stat name="ALU_cdb_duty_cycle" value="0.76"/>
			<stat name="MUL_cdb_duty_cycle" value="0.82"/>
			<stat name="FPU_cdb_duty_cycle" value="0.0"/>
		</component>
		<component id="system.core2" name="core2">
			<!-- Core property -->
			<param name="clock_rate" value="5"/>
			<!-- for cores with unknown timing, set to 0 to force off the opt flag -->
			<param name="opt_local" value="0"/>
			<param name="instruction_length" value="32"/>
			<param name="opcode_width" value="7"/>
			<param name="x86" value="0"/>
			<param name="micro_opcode_width" value="0"/>
			<param name="machine_type" value="1"/>
			<!-- inorder/OoO; 1 inorder; 0 OOO-->
			<param name="number_hardware_threads" value="1"/>
			<!-- number_instruction_fetch_ports(icache ports) is always 1 in single-thread processor,
			it only may be more than one in SMT processors. BTB ports always equals to fetch ports since 
			branch information in consecutive branch instructions in the same fetch group can be read out from BTB once.--> 
			<param name="fetch_width" value="0"/>
			<!-- fetch_width determines the size of cachelines of L1 cache block -->
			<param name="number_instruction_fetch_ports" value="0"/>
			<param name="decode_width" value="0"/>
			<!-- decode_width determines the number of ports of the 
			renaming table (both RAM and CAM) scheme -->
			<param name="issue_width" value="0"/>
			<param name="peak_issue_width" value="0"/>
			<!-- issue_width determines the number of ports of Issue window and other logic 
			as in the complexity effective processors paper; issue_width==dispatch_width -->
			<param name="commit_width" value="0"/>
			<!-- commit_width determines the number of ports of register files -->
			<param name="fp_issue_width" value="0"/>
			<param name="prediction_width" value="0"/> 
			<!-- number of branch instructions can be predicted simultaneously-->
			<!-- Current version of McPAT does not distinguish int and floating point pipelines 
			Theses parameters are reserved for future use.--> 
			<param name="pipelines_per_core" value="0,0"/>
			<!--integer_pipeline and floating_pipelines, if the floating_pipelines is 0, then the pipeline is shared-->
			<param name="pipeline_depth" value="0,0"/>
			<!-- pipeline depth of int and fp, if pipeline is shared, the second number is the average cycles of fp ops -->
			<!-- issue and exe unit-->
			<param name="ALU_per_core" value="1"/>
			<!-- contains an adder, a shifter, and a logical unit -->
			<param name="MUL_per_core" value="0"/>
			<!-- For MUL and Div -->
			<param name="FPU_per_core" value="0"/>		
			<!-- buffer between IF and ID stage -->
			<param name="instruction_buffer_size" value="0"/>
			<!-- buffer between ID and sche/exe stage -->
			<param name="decoded_stream_buffer_size" value="0"/>
			<param name="instruction_window_scheme" value="0"/><!-- 0 PHYREG based, 1 RSBASED-->
			<!-- McPAT support 2 types of OoO cores, RS based and physical reg based-->
			<param name="instruction_window_size" value="0"/>
			<param name="fp_instruction_window_size" value="0"/>
			<!-- Numbers need to be confirmed -->
			<!-- the instruction issue Q as in Alpha 21264; The RS as in Intel P6 -->
			<param name="ROB_size" value="0"/>
			<!-- each in-flight instruction has an entry in ROB -->
			<!-- registers -->
			<param name="archi_Regs_IRF_size" value="0"/>			
			<param name="archi_Regs_FRF_size" value="0"/>
			<!--  if OoO processor, phy_reg number is needed for renaming logic, 
			renaming logic is for both integer and floating point insts.  -->
			<param name="phy_Regs_IRF_size" value="0"/>
			<param name="phy_Regs_FRF_size" value="0"/>
			<!-- rename logic -->
			<param name="rename_scheme" value="0"/>
			<!-- can be RAM based(0) or CAM based(1) rename scheme 
			RAM-based scheme will have free list, status table;
			CAM-based scheme have the valid bit in the data field of the CAM -->
			<param name="checkpoint_depth" value="0"/>
			<!-- RAM and CAM RAT contains checkpoints, checkpoint_depth=# of in_flight speculations;
			RAM-based RAT should not have more than 4 GCs (e.g., MIPS R10000). 
			McPAT assumes the exsistance of RRAT when the RAM-RAT having no GCs (e.g., Netburst)
			CAM-based RAT should have at least 1 GC and can have more than 8 GCs. -->
			<param name="register_windows_size" value="0"/>
			<!-- how many windows in the windowed register file, sun processors;
			no register windowing is used when this number is 0 -->
			<!-- In OoO cores, loads and stores can be issued whether inorder(Pentium Pro) or (OoO)out-of-order(Alpha),
			They will always try to execute out-of-order though. -->
			<param name="LSU_order" value="inorder"/>
			<param name="store_buffer_size" value="0"/>
			<!-- By default, in-order cores do not have load buffers -->
			<param name="load_buffer_size" value="0"/>	
			<!-- number of ports refer to sustain-able concurrent memory accesses --> 
			<param name="memory_ports" value="0"/>	
			<!-- max_allowed_in_flight_memo_instructions determines the # of ports of load and store buffer
			as well as the ports of Dcache which is connected to LSU -->	
			<!-- dual-pumped Dcache can be used to save the extra read/write ports -->
			<param name="RAS_size" value="0"/>						
			<!-- general stats, defines simulation periods;require total, idle, and busy cycles for sanity check  -->
			<!-- please note: if target architecture is X86, then all the instructions refer to (fused) micro-ops -->
			<stat name="total_instructions" value="46128"/>
			<stat name="int_instructions" value="46128"/>
			<stat name="fp_instructions" value="0"/>
			<stat name="branch_instructions" value="0"/>
			<stat name="branch_mispredictions" value="0"/>
			<stat name="load_instructions" value="0"/>
			<stat name="store_instructions" value="0"/>
			<stat name="committed_instructions" value="0"/>
			<stat name="committed_int_instructions" value="0"/>
			<stat name="committed_fp_instructions" value="0"/>
			<stat name="pipeline_duty_cycle" value="1"/><!--<=1, runtime_ipc/peak_ipc; averaged for all cores if homogeneous -->
			<!-- the following cycle stats are used for heterogeneous cores only, 
				please ignore them if homogeneous cores -->
			<stat name="total_cycles" value="2660804"/>
			<stat name="idle_cycles" value="2614676"/>
			<stat name="busy_cycles"  value="46128"/>
			<!-- instruction buffer stats -->
			<!-- ROB stats, both RS and Phy based OoOs have ROB
			performance simulator should capture the difference on accesses,
			otherwise, McPAT has to guess based on number of committed instructions. -->
			<stat name="ROB_reads" value="0"/>
			<stat name="ROB_writes" value="0"/>
			<!-- RAT accesses -->
			<stat name="rename_reads" value="0"/> <!--lookup in renaming logic -->
			<stat name="rename_writes" value="0"/><!--update dest regs. renaming logic -->
			<stat name="fp_rename_reads" value="0"/>
			<stat name="fp_rename_writes" value="0"/>
			<!-- decode and rename stage use this, should be total ic - nop -->
			<!-- Inst window stats -->
			<stat name="inst_window_reads" value="0"/>
			<stat name="inst_window_writes" value="0"/>
			<stat name="inst_window_wakeup_accesses" value="0"/>
			<stat name="fp_inst_window_reads" value="0"/>
			<stat name="fp_inst_window_writes" value="0"/>
			<stat name="fp_inst_window_wakeup_accesses" value="0"/>
			<!--  RF accesses -->
			<stat name="int_regfile_reads" value="0"/>
			<stat name="float_regfile_reads" value="0"/>
			<stat name="int_regfile_writes" value="0"/>
			<stat name="float_regfile_writes" value="0"/>
			<!-- accesses to the working reg -->
			<stat name="function_calls" value="0"/>
			<stat name="context_switches" value="0"/>
			<!-- Number of Windows switches (number of function calls and returns)-->
			<!-- Alu stats by default, the processor has one FPU that includes the divider and 
			 multiplier. The fpu accesses should include accesses to multiplier and divider  -->
			<stat name="ialu_accesses" value="46128"/>			
			<stat name="fpu_accesses" value="0"/>
			<stat name="mul_accesses" value="0"/>
			<stat name="cdb_alu_accesses" value="0"/>
			<stat name="cdb_mul_accesses" value="0"/>
			<stat name="cdb_fpu_accesses" value="0"/>
			<!-- multiple cycle accesses should be counted multiple times, 
			otherwise, McPAT can use internal counter for different floating point instructions 
			to get final accesses. But that needs detailed info for floating point inst mix -->
			<!--  currently the performance simulator should 
			make sure all the numbers are final numbers, 
			including the explicit read/write accesses, 
			and the implicit accesses such as replacements and etc.
			Future versions of McPAT may be able to reason the implicit access
			based on param and stats of last level cache
			The same rule applies to all cache access stats too!  -->
			<!-- following is AF for max power computation. 
				Do not change them, unless you understand them-->
			<stat name="IFU_duty_cycle" value="0.9"/>
			<stat name="BR_duty_cycle" value="0.72"/><!--branch-->			
			<stat name="LSU_duty_cycle" value="0.71"/>
			<stat name="MemManU_I_duty_cycle" value="0.9"/>
			<stat name="MemManU_D_duty_cycle" value="0.71"/>
			<stat name="ALU_duty_cycle" value="0.76"/>
			<!-- (.78*2+.71)/3 -->
			<stat name="MUL_duty_cycle" value="0.82"/>
			<stat name="FPU_duty_cycle" value="0.0"/>
			<stat name="ALU_cdb_duty_cycle" value="0.76"/>
			<stat name="MUL_cdb_duty_cycle" value="0.82"/>
			<stat name="FPU_cdb_duty_cycle" value="0.0"/>
		</component>
		<component id="system.core3" name="core3">
			<!-- Core property -->
			<param name="clock_rate" value="5"/>
			<!-- for cores with unknown timing, set to 0 to force off the opt flag -->
			<param name="opt_local" value="0"/>
			<param name="instruction_length" value="32"/>
			<param name="opcode_width" value="7"/>
			<param name="x86" value="0"/>
			<param name="micro_opcode_width" value="0"/>
			<param name="machine_type" value="1"/>
			<!-- inorder/OoO; 1 inorder; 0 OOO-->
			<param name="number_hardware_threads" value="1"/>
			<!-- number_instruction_fetch_ports(icache ports) is always 1 in single-thread processor,
			it only may be more than one in SMT processors. BTB ports always equals to fetch ports since 
			branch information in consecutive branch instructions in the same fetch group can be read out from BTB once.--> 
			<param name="fetch_width" value="0"/>
			<!-- fetch_width determines the size of cachelines of L1 cache block -->
			<param name="number_instruction_fetch_ports" value="0"/>
			<param name="decode_width" value="0"/>
			<!-- decode_width determines the number of ports of the 
			renaming table (both RAM and CAM) scheme -->
			<param name="issue_width" value="0"/>
			<param name="peak_issue_width" value="0"/>
			<!-- issue_width determines the number of ports of Issue window and other logic 
			as in the complexity effective processors paper; issue_width==dispatch_width -->
			<param name="commit_width" value="0"/>
			<!-- commit_width determines the number of ports of register files -->
			<param name="fp_issue_width" value="0"/>
			<param name="prediction_width" value="0"/> 
			<!-- number of branch instructions can be predicted simultaneously-->
			<!-- Current version of McPAT does not distinguish int and floating point pipelines 
			Theses parameters are reserved for future use.--> 
			<param name="pipelines_per_core" value="0,0"/>
			<!--integer_pipeline and floating_pipelines, if the floating_pipelines is 0, then the pipeline is shared-->
			<param name="pipeline_depth" value="0,0"/>
			<!-- pipeline depth of int and fp, if pipeline is shared, the second number is the average cycles of fp ops -->
			<!-- issue and exe unit-->
			<param name="ALU_per_core" value="1"/>
			<!-- contains an adder, a shifter, and a logical unit -->
			<param name="MUL_per_core" value="0"/>
			<!-- For MUL and Div -->
			<param name="FPU_per_core" value="0"/>		
			<!-- buffer between IF and ID stage -->
			<param name="instruction_buffer_size" value="0"/>
			<!-- buffer between ID and sche/exe stage -->
			<param name="decoded_stream_buffer_size" value="0"/>
			<param name="instruction_window_scheme" value="0"/><!-- 0 PHYREG based, 1 RSBASED-->
			<!-- McPAT support 2 types of OoO cores, RS based and physical reg based-->
			<param name="instruction_window_size" value="0"/>
			<param name="fp_instruction_window_size" value="0"/>
			<!-- Numbers need to be confirmed -->
			<!-- the instruction issue Q as in Alpha 21264; The RS as in Intel P6 -->
			<param name="ROB_size" value="0"/>
			<!-- each in-flight instruction has an entry in ROB -->
			<!-- registers -->
			<param name="archi_Regs_IRF_size" value="0"/>			
			<param name="archi_Regs_FRF_size" value="0"/>
			<!--  if OoO processor, phy_reg number is needed for renaming logic, 
			renaming logic is for both integer and floating point insts.  -->
			<param name="phy_Regs_IRF_size" value="0"/>
			<param name="phy_Regs_FRF_size" value="0"/>
			<!-- rename logic -->
			<param name="rename_scheme" value="0"/>
			<!-- can be RAM based(0) or CAM based(1) rename scheme 
			RAM-based scheme will have free list, status table;
			CAM-based scheme have the valid bit in the data field of the CAM -->
			<param name="checkpoint_depth" value="0"/>
			<!-- RAM and CAM RAT contains checkpoints, checkpoint_depth=# of in_flight speculations;
			RAM-based RAT should not have more than 4 GCs (e.g., MIPS R10000). 
			McPAT assumes the exsistance of RRAT when the RAM-RAT having no GCs (e.g., Netburst)
			CAM-based RAT should have at least 1 GC and can have more than 8 GCs. -->
			<param name="register_windows_size" value="0"/>
			<!-- how many windows in the windowed register file, sun processors;
			no register windowing is used when this number is 0 -->
			<!-- In OoO cores, loads and stores can be issued whether inorder(Pentium Pro) or (OoO)out-of-order(Alpha),
			They will always try to execute out-of-order though. -->
			<param name="LSU_order" value="inorder"/>
			<param name="store_buffer_size" value="0"/>
			<!-- By default, in-order cores do not have load buffers -->
			<param name="load_buffer_size" value="0"/>	
			<!-- number of ports refer to sustain-able concurrent memory accesses --> 
			<param name="memory_ports" value="0"/>	
			<!-- max_allowed_in_flight_memo_instructions determines the # of ports of load and store buffer
			as well as the ports of Dcache which is connected to LSU -->	
			<!-- dual-pumped Dcache can be used to save the extra read/write ports -->
			<param name="RAS_size" value="0"/>						
			<!-- general stats, defines simulation periods;require total, idle, and busy cycles for sanity check  -->
			<!-- please note: if target architecture is X86, then all the instructions refer to (fused) micro-ops -->
			<stat name="total_instructions" value="46128"/>
			<stat name="int_instructions" value="46128"/>
			<stat name="fp_instructions" value="0"/>
			<stat name="branch_instructions" value="0"/>
			<stat name="branch_mispredictions" value="0"/>
			<stat name="load_instructions" value="0"/>
			<stat name="store_instructions" value="0"/>
			<stat name="committed_instructions" value="0"/>
			<stat name="committed_int_instructions" value="0"/>
			<stat name="committed_fp_instructions" value="0"/>
			<stat name="pipeline_duty_cycle" value="1"/><!--<=1, runtime_ipc/peak_ipc; averaged for all cores if homogeneous -->
			<!-- the following cycle stats are used for heterogeneous cores only, 
				please ignore them if homogeneous cores -->
			<stat name="total_cycles" value="2660804"/>
			<stat name="idle_cycles" value="2614676"/>
			<stat name="busy_cycles"  value="46128"/>
			<!-- instruction buffer stats -->
			<!-- ROB stats, both RS and Phy based OoOs have ROB
			performance simulator should capture the difference on accesses,
			otherwise, McPAT has to guess based on number of committed instructions. -->
			<stat name="ROB_reads" value="0"/>
			<stat name="ROB_writes" value="0"/>
			<!-- RAT accesses -->
			<stat name="rename_reads" value="0"/> <!--lookup in renaming logic -->
			<stat name="rename_writes" value="0"/><!--update dest regs. renaming logic -->
			<stat name="fp_rename_reads" value="0"/>
			<stat name="fp_rename_writes" value="0"/>
			<!-- decode and rename stage use this, should be total ic - nop -->
			<!-- Inst window stats -->
			<stat name="inst_window_reads" value="0"/>
			<stat name="inst_window_writes" value="0"/>
			<stat name="inst_window_wakeup_accesses" value="0"/>
			<stat name="fp_inst_window_reads" value="0"/>
			<stat name="fp_inst_window_writes" value="0"/>
			<stat name="fp_inst_window_wakeup_accesses" value="0"/>
			<!--  RF accesses -->
			<stat name="int_regfile_reads" value="0"/>
			<stat name="float_regfile_reads" value="0"/>
			<stat name="int_regfile_writes" value="0"/>
			<stat name="float_regfile_writes" value="0"/>
			<!-- accesses to the working reg -->
			<stat name="function_calls" value="0"/>
			<stat name="context_switches" value="0"/>
			<!-- Number of Windows switches (number of function calls and returns)-->
			<!-- Alu stats by default, the processor has one FPU that includes the divider and 
			 multiplier. The fpu accesses should include accesses to multiplier and divider  -->
			<stat name="ialu_accesses" value="46128"/>			
			<stat name="fpu_accesses" value="0"/>
			<stat name="mul_accesses" value="0"/>
			<stat name="cdb_alu_accesses" value="0"/>
			<stat name="cdb_mul_accesses" value="0"/>
			<stat name="cdb_fpu_accesses" value="0"/>
			<!-- multiple cycle accesses should be counted multiple times, 
			otherwise, McPAT can use internal counter for different floating point instructions 
			to get final accesses. But that needs detailed info for floating point inst mix -->
			<!--  currently the performance simulator should 
			make sure all the numbers are final numbers, 
			including the explicit read/write accesses, 
			and the implicit accesses such as replacements and etc.
			Future versions of McPAT may be able to reason the implicit access
			based on param and stats of last level cache
			The same rule applies to all cache access stats too!  -->
			<!-- following is AF for max power computation. 
				Do not change them, unless you understand them-->
			<stat name="IFU_duty_cycle" value="0.9"/>
			<stat name="BR_duty_cycle" value="0.72"/><!--branch-->			
			<stat name="LSU_duty_cycle" value="0.71"/>
			<stat name="MemManU_I_duty_cycle" value="0.9"/>
			<stat name="MemManU_D_duty_cycle" value="0.71"/>
			<stat name="ALU_duty_cycle" value="0.76"/>
			<!-- (.78*2+.71)/3 -->
			<stat name="MUL_duty_cycle" value="0.82"/>
			<stat name="FPU_duty_cycle" value="0.0"/>
			<stat name="ALU_cdb_duty_cycle" value="0.76"/>
			<stat name="MUL_cdb_duty_cycle" value="0.82"/>
			<stat name="FPU_cdb_duty_cycle" value="0.0"/>
		</component>
		<component id="system.core4" name="core4">
			<!-- Core property -->
			<param name="clock_rate" value="5"/>
			<!-- for cores with unknown timing, set to 0 to force off the opt flag -->
			<param name="opt_local" value="0"/>
			<param name="instruction_length" value="32"/>
			<param name="opcode_width" value="7"/>
			<param name="x86" value="0"/>
			<param name="micro_opcode_width" value="0"/>
			<param name="machine_type" value="1"/>
			<!-- inorder/OoO; 1 inorder; 0 OOO-->
			<param name="number_hardware_threads" value="1"/>
			<!-- number_instruction_fetch_ports(icache ports) is always 1 in single-thread processor,
			it only may be more than one in SMT processors. BTB ports always equals to fetch ports since 
			branch information in consecutive branch instructions in the same fetch group can be read out from BTB once.--> 
			<param name="fetch_width" value="0"/>
			<!-- fetch_width determines the size of cachelines of L1 cache block -->
			<param name="number_instruction_fetch_ports" value="0"/>
			<param name="decode_width" value="0"/>
			<!-- decode_width determines the number of ports of the 
			renaming table (both RAM and CAM) scheme -->
			<param name="issue_width" value="0"/>
			<param name="peak_issue_width" value="0"/>
			<!-- issue_width determines the number of ports of Issue window and other logic 
			as in the complexity effective processors paper; issue_width==dispatch_width -->
			<param name="commit_width" value="0"/>
			<!-- commit_width determines the number of ports of register files -->
			<param name="fp_issue_width" value="0"/>
			<param name="prediction_width" value="0"/> 
			<!-- number of branch instructions can be predicted simultaneously-->
			<!-- Current version of McPAT does not distinguish int and floating point pipelines 
			Theses parameters are reserved for future use.--> 
			<param name="pipelines_per_core" value="0,0"/>
			<!--integer_pipeline and floating_pipelines, if the floating_pipelines is 0, then the pipeline is shared-->
			<param name="pipeline_depth" value="0,0"/>
			<!-- pipeline depth of int and fp, if pipeline is shared, the second number is the average cycles of fp ops -->
			<!-- issue and exe unit-->
			<param name="ALU_per_core" value="1"/>
			<!-- contains an adder, a shifter, and a logical unit -->
			<param name="MUL_per_core" value="0"/>
			<!-- For MUL and Div -->
			<param name="FPU_per_core" value="0"/>		
			<!-- buffer between IF and ID stage -->
			<param name="instruction_buffer_size" value="0"/>
			<!-- buffer between ID and sche/exe stage -->
			<param name="decoded_stream_buffer_size" value="0"/>
			<param name="instruction_window_scheme" value="0"/><!-- 0 PHYREG based, 1 RSBASED-->
			<!-- McPAT support 2 types of OoO cores, RS based and physical reg based-->
			<param name="instruction_window_size" value="0"/>
			<param name="fp_instruction_window_size" value="0"/>
			<!-- Numbers need to be confirmed -->
			<!-- the instruction issue Q as in Alpha 21264; The RS as in Intel P6 -->
			<param name="ROB_size" value="0"/>
			<!-- each in-flight instruction has an entry in ROB -->
			<!-- registers -->
			<param name="archi_Regs_IRF_size" value="0"/>			
			<param name="archi_Regs_FRF_size" value="0"/>
			<!--  if OoO processor, phy_reg number is needed for renaming logic, 
			renaming logic is for both integer and floating point insts.  -->
			<param name="phy_Regs_IRF_size" value="0"/>
			<param name="phy_Regs_FRF_size" value="0"/>
			<!-- rename logic -->
			<param name="rename_scheme" value="0"/>
			<!-- can be RAM based(0) or CAM based(1) rename scheme 
			RAM-based scheme will have free list, status table;
			CAM-based scheme have the valid bit in the data field of the CAM -->
			<param name="checkpoint_depth" value="0"/>
			<!-- RAM and CAM RAT contains checkpoints, checkpoint_depth=# of in_flight speculations;
			RAM-based RAT should not have more than 4 GCs (e.g., MIPS R10000). 
			McPAT assumes the exsistance of RRAT when the RAM-RAT having no GCs (e.g., Netburst)
			CAM-based RAT should have at least 1 GC and can have more than 8 GCs. -->
			<param name="register_windows_size" value="0"/>
			<!-- how many windows in the windowed register file, sun processors;
			no register windowing is used when this number is 0 -->
			<!-- In OoO cores, loads and stores can be issued whether inorder(Pentium Pro) or (OoO)out-of-order(Alpha),
			They will always try to execute out-of-order though. -->
			<param name="LSU_order" value="inorder"/>
			<param name="store_buffer_size" value="0"/>
			<!-- By default, in-order cores do not have load buffers -->
			<param name="load_buffer_size" value="0"/>	
			<!-- number of ports refer to sustain-able concurrent memory accesses --> 
			<param name="memory_ports" value="0"/>	
			<!-- max_allowed_in_flight_memo_instructions determines the # of ports of load and store buffer
			as well as the ports of Dcache which is connected to LSU -->	
			<!-- dual-pumped Dcache can be used to save the extra read/write ports -->
			<param name="RAS_size" value="0"/>						
			<!-- general stats, defines simulation periods;require total, idle, and busy cycles for sanity check  -->
			<!-- please note: if target architecture is X86, then all the instructions refer to (fused) micro-ops -->
			<stat name="total_instructions" value="38440"/>
			<stat name="int_instructions" value="38440"/>
			<stat name="fp_instructions" value="0"/>
			<stat name="branch_instructions" value="0"/>
			<stat name="branch_mispredictions" value="0"/>
			<stat name="load_instructions" value="0"/>
			<stat name="store_instructions" value="0"/>
			<stat name="committed_instructions" value="0"/>
			<stat name="committed_int_instructions" value="0"/>
			<stat name="committed_fp_instructions" value="0"/>
			<stat name="pipeline_duty_cycle" value="1"/><!--<=1, runtime_ipc/peak_ipc; averaged for all cores if homogeneous -->
			<!-- the following cycle stats are used for heterogeneous cores only, 
				please ignore them if homogeneous cores -->
			<stat name="total_cycles" value="2660804"/>
			<stat name="idle_cycles" value="2622364"/>
			<stat name="busy_cycles"  value="38440"/>
			<!-- instruction buffer stats -->
			<!-- ROB stats, both RS and Phy based OoOs have ROB
			performance simulator should capture the difference on accesses,
			otherwise, McPAT has to guess based on number of committed instructions. -->
			<stat name="ROB_reads" value="0"/>
			<stat name="ROB_writes" value="0"/>
			<!-- RAT accesses -->
			<stat name="rename_reads" value="0"/> <!--lookup in renaming logic -->
			<stat name="rename_writes" value="0"/><!--update dest regs. renaming logic -->
			<stat name="fp_rename_reads" value="0"/>
			<stat name="fp_rename_writes" value="0"/>
			<!-- decode and rename stage use this, should be total ic - nop -->
			<!-- Inst window stats -->
			<stat name="inst_window_reads" value="0"/>
			<stat name="inst_window_writes" value="0"/>
			<stat name="inst_window_wakeup_accesses" value="0"/>
			<stat name="fp_inst_window_reads" value="0"/>
			<stat name="fp_inst_window_writes" value="0"/>
			<stat name="fp_inst_window_wakeup_accesses" value="0"/>
			<!--  RF accesses -->
			<stat name="int_regfile_reads" value="0"/>
			<stat name="float_regfile_reads" value="0"/>
			<stat name="int_regfile_writes" value="0"/>
			<stat name="float_regfile_writes" value="0"/>
			<!-- accesses to the working reg -->
			<stat name="function_calls" value="0"/>
			<stat name="context_switches" value="0"/>
			<!-- Number of Windows switches (number of function calls and returns)-->
			<!-- Alu stats by default, the processor has one FPU that includes the divider and 
			 multiplier. The fpu accesses should include accesses to multiplier and divider  -->
			<stat name="ialu_accesses" value="38440"/>			
			<stat name="fpu_accesses" value="0"/>
			<stat name="mul_accesses" value="0"/>
			<stat name="cdb_alu_accesses" value="0"/>
			<stat name="cdb_mul_accesses" value="0"/>
			<stat name="cdb_fpu_accesses" value="0"/>
			<!-- multiple cycle accesses should be counted multiple times, 
			otherwise, McPAT can use internal counter for different floating point instructions 
			to get final accesses. But that needs detailed info for floating point inst mix -->
			<!--  currently the performance simulator should 
			make sure all the numbers are final numbers, 
			including the explicit read/write accesses, 
			and the implicit accesses such as replacements and etc.
			Future versions of McPAT may be able to reason the implicit access
			based on param and stats of last level cache
			The same rule applies to all cache access stats too!  -->
			<!-- following is AF for max power computation. 
				Do not change them, unless you understand them-->
			<stat name="IFU_duty_cycle" value="0.9"/>
			<stat name="BR_duty_cycle" value="0.72"/><!--branch-->			
			<stat name="LSU_duty_cycle" value="0.71"/>
			<stat name="MemManU_I_duty_cycle" value="0.9"/>
			<stat name="MemManU_D_duty_cycle" value="0.71"/>
			<stat name="ALU_duty_cycle" value="0.76"/>
			<!-- (.78*2+.71)/3 -->
			<stat name="MUL_duty_cycle" value="0.82"/>
			<stat name="FPU_duty_cycle" value="0.0"/>
			<stat name="ALU_cdb_duty_cycle" value="0.76"/>
			<stat name="MUL_cdb_duty_cycle" value="0.82"/>
			<stat name="FPU_cdb_duty_cycle" value="0.0"/>
		</component>
		<component id="system.core5" name="core5">
			<!-- Core property -->
			<param name="clock_rate" value="5"/>
			<!-- for cores with unknown timing, set to 0 to force off the opt flag -->
			<param name="opt_local" value="0"/>
			<param name="instruction_length" value="32"/>
			<param name="opcode_width" value="7"/>
			<param name="x86" value="0"/>
			<param name="micro_opcode_width" value="0"/>
			<param name="machine_type" value="1"/>
			<!-- inorder/OoO; 1 inorder; 0 OOO-->
			<param name="number_hardware_threads" value="1"/>
			<!-- number_instruction_fetch_ports(icache ports) is always 1 in single-thread processor,
			it only may be more than one in SMT processors. BTB ports always equals to fetch ports since 
			branch information in consecutive branch instructions in the same fetch group can be read out from BTB once.--> 
			<param name="fetch_width" value="0"/>
			<!-- fetch_width determines the size of cachelines of L1 cache block -->
			<param name="number_instruction_fetch_ports" value="0"/>
			<param name="decode_width" value="0"/>
			<!-- decode_width determines the number of ports of the 
			renaming table (both RAM and CAM) scheme -->
			<param name="issue_width" value="0"/>
			<param name="peak_issue_width" value="0"/>
			<!-- issue_width determines the number of ports of Issue window and other logic 
			as in the complexity effective processors paper; issue_width==dispatch_width -->
			<param name="commit_width" value="0"/>
			<!-- commit_width determines the number of ports of register files -->
			<param name="fp_issue_width" value="0"/>
			<param name="prediction_width" value="0"/> 
			<!-- number of branch instructions can be predicted simultaneously-->
			<!-- Current version of McPAT does not distinguish int and floating point pipelines 
			Theses parameters are reserved for future use.--> 
			<param name="pipelines_per_core" value="0,0"/>
			<!--integer_pipeline and floating_pipelines, if the floating_pipelines is 0, then the pipeline is shared-->
			<param name="pipeline_depth" value="0,0"/>
			<!-- pipeline depth of int and fp, if pipeline is shared, the second number is the average cycles of fp ops -->
			<!-- issue and exe unit-->
			<param name="ALU_per_core" value="1"/>
			<!-- contains an adder, a shifter, and a logical unit -->
			<param name="MUL_per_core" value="0"/>
			<!-- For MUL and Div -->
			<param name="FPU_per_core" value="0"/>		
			<!-- buffer between IF and ID stage -->
			<param name="instruction_buffer_size" value="0"/>
			<!-- buffer between ID and sche/exe stage -->
			<param name="decoded_stream_buffer_size" value="0"/>
			<param name="instruction_window_scheme" value="0"/><!-- 0 PHYREG based, 1 RSBASED-->
			<!-- McPAT support 2 types of OoO cores, RS based and physical reg based-->
			<param name="instruction_window_size" value="0"/>
			<param name="fp_instruction_window_size" value="0"/>
			<!-- Numbers need to be confirmed -->
			<!-- the instruction issue Q as in Alpha 21264; The RS as in Intel P6 -->
			<param name="ROB_size" value="0"/>
			<!-- each in-flight instruction has an entry in ROB -->
			<!-- registers -->
			<param name="archi_Regs_IRF_size" value="0"/>			
			<param name="archi_Regs_FRF_size" value="0"/>
			<!--  if OoO processor, phy_reg number is needed for renaming logic, 
			renaming logic is for both integer and floating point insts.  -->
			<param name="phy_Regs_IRF_size" value="0"/>
			<param name="phy_Regs_FRF_size" value="0"/>
			<!-- rename logic -->
			<param name="rename_scheme" value="0"/>
			<!-- can be RAM based(0) or CAM based(1) rename scheme 
			RAM-based scheme will have free list, status table;
			CAM-based scheme have the valid bit in the data field of the CAM -->
			<param name="checkpoint_depth" value="0"/>
			<!-- RAM and CAM RAT contains checkpoints, checkpoint_depth=# of in_flight speculations;
			RAM-based RAT should not have more than 4 GCs (e.g., MIPS R10000). 
			McPAT assumes the exsistance of RRAT when the RAM-RAT having no GCs (e.g., Netburst)
			CAM-based RAT should have at least 1 GC and can have more than 8 GCs. -->
			<param name="register_windows_size" value="0"/>
			<!-- how many windows in the windowed register file, sun processors;
			no register windowing is used when this number is 0 -->
			<!-- In OoO cores, loads and stores can be issued whether inorder(Pentium Pro) or (OoO)out-of-order(Alpha),
			They will always try to execute out-of-order though. -->
			<param name="LSU_order" value="inorder"/>
			<param name="store_buffer_size" value="0"/>
			<!-- By default, in-order cores do not have load buffers -->
			<param name="load_buffer_size" value="0"/>	
			<!-- number of ports refer to sustain-able concurrent memory accesses --> 
			<param name="memory_ports" value="0"/>	
			<!-- max_allowed_in_flight_memo_instructions determines the # of ports of load and store buffer
			as well as the ports of Dcache which is connected to LSU -->	
			<!-- dual-pumped Dcache can be used to save the extra read/write ports -->
			<param name="RAS_size" value="0"/>						
			<!-- general stats, defines simulation periods;require total, idle, and busy cycles for sanity check  -->
			<!-- please note: if target architecture is X86, then all the instructions refer to (fused) micro-ops -->
			<stat name="total_instructions" value="23064"/>
			<stat name="int_instructions" value="23064"/>
			<stat name="fp_instructions" value="0"/>
			<stat name="branch_instructions" value="0"/>
			<stat name="branch_mispredictions" value="0"/>
			<stat name="load_instructions" value="0"/>
			<stat name="store_instructions" value="0"/>
			<stat name="committed_instructions" value="0"/>
			<stat name="committed_int_instructions" value="0"/>
			<stat name="committed_fp_instructions" value="0"/>
			<stat name="pipeline_duty_cycle" value="1"/><!--<=1, runtime_ipc/peak_ipc; averaged for all cores if homogeneous -->
			<!-- the following cycle stats are used for heterogeneous cores only, 
				please ignore them if homogeneous cores -->
			<stat name="total_cycles" value="2660804"/>
			<stat name="idle_cycles" value="2637740"/>
			<stat name="busy_cycles"  value="23064"/>
			<!-- instruction buffer stats -->
			<!-- ROB stats, both RS and Phy based OoOs have ROB
			performance simulator should capture the difference on accesses,
			otherwise, McPAT has to guess based on number of committed instructions. -->
			<stat name="ROB_reads" value="0"/>
			<stat name="ROB_writes" value="0"/>
			<!-- RAT accesses -->
			<stat name="rename_reads" value="0"/> <!--lookup in renaming logic -->
			<stat name="rename_writes" value="0"/><!--update dest regs. renaming logic -->
			<stat name="fp_rename_reads" value="0"/>
			<stat name="fp_rename_writes" value="0"/>
			<!-- decode and rename stage use this, should be total ic - nop -->
			<!-- Inst window stats -->
			<stat name="inst_window_reads" value="0"/>
			<stat name="inst_window_writes" value="0"/>
			<stat name="inst_window_wakeup_accesses" value="0"/>
			<stat name="fp_inst_window_reads" value="0"/>
			<stat name="fp_inst_window_writes" value="0"/>
			<stat name="fp_inst_window_wakeup_accesses" value="0"/>
			<!--  RF accesses -->
			<stat name="int_regfile_reads" value="0"/>
			<stat name="float_regfile_reads" value="0"/>
			<stat name="int_regfile_writes" value="0"/>
			<stat name="float_regfile_writes" value="0"/>
			<!-- accesses to the working reg -->
			<stat name="function_calls" value="0"/>
			<stat name="context_switches" value="0"/>
			<!-- Number of Windows switches (number of function calls and returns)-->
			<!-- Alu stats by default, the processor has one FPU that includes the divider and 
			 multiplier. The fpu accesses should include accesses to multiplier and divider  -->
			<stat name="ialu_accesses" value="23064"/>			
			<stat name="fpu_accesses" value="0"/>
			<stat name="mul_accesses" value="0"/>
			<stat name="cdb_alu_accesses" value="0"/>
			<stat name="cdb_mul_accesses" value="0"/>
			<stat name="cdb_fpu_accesses" value="0"/>
			<!-- multiple cycle accesses should be counted multiple times, 
			otherwise, McPAT can use internal counter for different floating point instructions 
			to get final accesses. But that needs detailed info for floating point inst mix -->
			<!--  currently the performance simulator should 
			make sure all the numbers are final numbers, 
			including the explicit read/write accesses, 
			and the implicit accesses such as replacements and etc.
			Future versions of McPAT may be able to reason the implicit access
			based on param and stats of last level cache
			The same rule applies to all cache access stats too!  -->
			<!-- following is AF for max power computation. 
				Do not change them, unless you understand them-->
			<stat name="IFU_duty_cycle" value="0.9"/>
			<stat name="BR_duty_cycle" value="0.72"/><!--branch-->			
			<stat name="LSU_duty_cycle" value="0.71"/>
			<stat name="MemManU_I_duty_cycle" value="0.9"/>
			<stat name="MemManU_D_duty_cycle" value="0.71"/>
			<stat name="ALU_duty_cycle" value="0.76"/>
			<!-- (.78*2+.71)/3 -->
			<stat name="MUL_duty_cycle" value="0.82"/>
			<stat name="FPU_duty_cycle" value="0.0"/>
			<stat name="ALU_cdb_duty_cycle" value="0.76"/>
			<stat name="MUL_cdb_duty_cycle" value="0.82"/>
			<stat name="FPU_cdb_duty_cycle" value="0.0"/>
		</component>
		<component id="system.core6" name="core6">
			<!-- Core property -->
			<param name="clock_rate" value="5"/>
			<!-- for cores with unknown timing, set to 0 to force off the opt flag -->
			<param name="opt_local" value="0"/>
			<param name="instruction_length" value="32"/>
			<param name="opcode_width" value="7"/>
			<param name="x86" value="0"/>
			<param name="micro_opcode_width" value="0"/>
			<param name="machine_type" value="1"/>
			<!-- inorder/OoO; 1 inorder; 0 OOO-->
			<param name="number_hardware_threads" value="1"/>
			<!-- number_instruction_fetch_ports(icache ports) is always 1 in single-thread processor,
			it only may be more than one in SMT processors. BTB ports always equals to fetch ports since 
			branch information in consecutive branch instructions in the same fetch group can be read out from BTB once.--> 
			<param name="fetch_width" value="0"/>
			<!-- fetch_width determines the size of cachelines of L1 cache block -->
			<param name="number_instruction_fetch_ports" value="0"/>
			<param name="decode_width" value="0"/>
			<!-- decode_width determines the number of ports of the 
			renaming table (both RAM and CAM) scheme -->
			<param name="issue_width" value="0"/>
			<param name="peak_issue_width" value="0"/>
			<!-- issue_width determines the number of ports of Issue window and other logic 
			as in the complexity effective processors paper; issue_width==dispatch_width -->
			<param name="commit_width" value="0"/>
			<!-- commit_width determines the number of ports of register files -->
			<param name="fp_issue_width" value="0"/>
			<param name="prediction_width" value="0"/> 
			<!-- number of branch instructions can be predicted simultaneously-->
			<!-- Current version of McPAT does not distinguish int and floating point pipelines 
			Theses parameters are reserved for future use.--> 
			<param name="pipelines_per_core" value="0,0"/>
			<!--integer_pipeline and floating_pipelines, if the floating_pipelines is 0, then the pipeline is shared-->
			<param name="pipeline_depth" value="0,0"/>
			<!-- pipeline depth of int and fp, if pipeline is shared, the second number is the average cycles of fp ops -->
			<!-- issue and exe unit-->
			<param name="ALU_per_core" value="1"/>
			<!-- contains an adder, a shifter, and a logical unit -->
			<param name="MUL_per_core" value="0"/>
			<!-- For MUL and Div -->
			<param name="FPU_per_core" value="0"/>		
			<!-- buffer between IF and ID stage -->
			<param name="instruction_buffer_size" value="0"/>
			<!-- buffer between ID and sche/exe stage -->
			<param name="decoded_stream_buffer_size" value="0"/>
			<param name="instruction_window_scheme" value="0"/><!-- 0 PHYREG based, 1 RSBASED-->
			<!-- McPAT support 2 types of OoO cores, RS based and physical reg based-->
			<param name="instruction_window_size" value="0"/>
			<param name="fp_instruction_window_size" value="0"/>
			<!-- Numbers need to be confirmed -->
			<!-- the instruction issue Q as in Alpha 21264; The RS as in Intel P6 -->
			<param name="ROB_size" value="0"/>
			<!-- each in-flight instruction has an entry in ROB -->
			<!-- registers -->
			<param name="archi_Regs_IRF_size" value="0"/>			
			<param name="archi_Regs_FRF_size" value="0"/>
			<!--  if OoO processor, phy_reg number is needed for renaming logic, 
			renaming logic is for both integer and floating point insts.  -->
			<param name="phy_Regs_IRF_size" value="0"/>
			<param name="phy_Regs_FRF_size" value="0"/>
			<!-- rename logic -->
			<param name="rename_scheme" value="0"/>
			<!-- can be RAM based(0) or CAM based(1) rename scheme 
			RAM-based scheme will have free list, status table;
			CAM-based scheme have the valid bit in the data field of the CAM -->
			<param name="checkpoint_depth" value="0"/>
			<!-- RAM and CAM RAT contains checkpoints, checkpoint_depth=# of in_flight speculations;
			RAM-based RAT should not have more than 4 GCs (e.g., MIPS R10000). 
			McPAT assumes the exsistance of RRAT when the RAM-RAT having no GCs (e.g., Netburst)
			CAM-based RAT should have at least 1 GC and can have more than 8 GCs. -->
			<param name="register_windows_size" value="0"/>
			<!-- how many windows in the windowed register file, sun processors;
			no register windowing is used when this number is 0 -->
			<!-- In OoO cores, loads and stores can be issued whether inorder(Pentium Pro) or (OoO)out-of-order(Alpha),
			They will always try to execute out-of-order though. -->
			<param name="LSU_order" value="inorder"/>
			<param name="store_buffer_size" value="0"/>
			<!-- By default, in-order cores do not have load buffers -->
			<param name="load_buffer_size" value="0"/>	
			<!-- number of ports refer to sustain-able concurrent memory accesses --> 
			<param name="memory_ports" value="0"/>	
			<!-- max_allowed_in_flight_memo_instructions determines the # of ports of load and store buffer
			as well as the ports of Dcache which is connected to LSU -->	
			<!-- dual-pumped Dcache can be used to save the extra read/write ports -->
			<param name="RAS_size" value="0"/>						
			<!-- general stats, defines simulation periods;require total, idle, and busy cycles for sanity check  -->
			<!-- please note: if target architecture is X86, then all the instructions refer to (fused) micro-ops -->
			<stat name="total_instructions" value="46128"/>
			<stat name="int_instructions" value="46128"/>
			<stat name="fp_instructions" value="0"/>
			<stat name="branch_instructions" value="0"/>
			<stat name="branch_mispredictions" value="0"/>
			<stat name="load_instructions" value="0"/>
			<stat name="store_instructions" value="0"/>
			<stat name="committed_instructions" value="0"/>
			<stat name="committed_int_instructions" value="0"/>
			<stat name="committed_fp_instructions" value="0"/>
			<stat name="pipeline_duty_cycle" value="1"/><!--<=1, runtime_ipc/peak_ipc; averaged for all cores if homogeneous -->
			<!-- the following cycle stats are used for heterogeneous cores only, 
				please ignore them if homogeneous cores -->
			<stat name="total_cycles" value="2660804"/>
			<stat name="idle_cycles" value="2614676"/>
			<stat name="busy_cycles"  value="46128"/>
			<!-- instruction buffer stats -->
			<!-- ROB stats, both RS and Phy based OoOs have ROB
			performance simulator should capture the difference on accesses,
			otherwise, McPAT has to guess based on number of committed instructions. -->
			<stat name="ROB_reads" value="0"/>
			<stat name="ROB_writes" value="0"/>
			<!-- RAT accesses -->
			<stat name="rename_reads" value="0"/> <!--lookup in renaming logic -->
			<stat name="rename_writes" value="0"/><!--update dest regs. renaming logic -->
			<stat name="fp_rename_reads" value="0"/>
			<stat name="fp_rename_writes" value="0"/>
			<!-- decode and rename stage use this, should be total ic - nop -->
			<!-- Inst window stats -->
			<stat name="inst_window_reads" value="0"/>
			<stat name="inst_window_writes" value="0"/>
			<stat name="inst_window_wakeup_accesses" value="0"/>
			<stat name="fp_inst_window_reads" value="0"/>
			<stat name="fp_inst_window_writes" value="0"/>
			<stat name="fp_inst_window_wakeup_accesses" value="0"/>
			<!--  RF accesses -->
			<stat name="int_regfile_reads" value="0"/>
			<stat name="float_regfile_reads" value="0"/>
			<stat name="int_regfile_writes" value="0"/>
			<stat name="float_regfile_writes" value="0"/>
			<!-- accesses to the working reg -->
			<stat name="function_calls" value="0"/>
			<stat name="context_switches" value="0"/>
			<!-- Number of Windows switches (number of function calls and returns)-->
			<!-- Alu stats by default, the processor has one FPU that includes the divider and 
			 multiplier. The fpu accesses should include accesses to multiplier and divider  -->
			<stat name="ialu_accesses" value="46128"/>			
			<stat name="fpu_accesses" value="0"/>
			<stat name="mul_accesses" value="0"/>
			<stat name="cdb_alu_accesses" value="0"/>
			<stat name="cdb_mul_accesses" value="0"/>
			<stat name="cdb_fpu_accesses" value="0"/>
			<!-- multiple cycle accesses should be counted multiple times, 
			otherwise, McPAT can use internal counter for different floating point instructions 
			to get final accesses. But that needs detailed info for floating point inst mix -->
			<!--  currently the performance simulator should 
			make sure all the numbers are final numbers, 
			including the explicit read/write accesses, 
			and the implicit accesses such as replacements and etc.
			Future versions of McPAT may be able to reason the implicit access
			based on param and stats of last level cache
			The same rule applies to all cache access stats too!  -->
			<!-- following is AF for max power computation. 
				Do not change them, unless you understand them-->
			<stat name="IFU_duty_cycle" value="0.9"/>
			<stat name="BR_duty_cycle" value="0.72"/><!--branch-->			
			<stat name="LSU_duty_cycle" value="0.71"/>
			<stat name="MemManU_I_duty_cycle" value="0.9"/>
			<stat name="MemManU_D_duty_cycle" value="0.71"/>
			<stat name="ALU_duty_cycle" value="0.76"/>
			<!-- (.78*2+.71)/3 -->
			<stat name="MUL_duty_cycle" value="0.82"/>
			<stat name="FPU_duty_cycle" value="0.0"/>
			<stat name="ALU_cdb_duty_cycle" value="0.76"/>
			<stat name="MUL_cdb_duty_cycle" value="0.82"/>
			<stat name="FPU_cdb_duty_cycle" value="0.0"/>
		</component>
		<component id="system.core7" name="core7">
			<!-- Core property -->
			<param name="clock_rate" value="5"/>
			<!-- for cores with unknown timing, set to 0 to force off the opt flag -->
			<param name="opt_local" value="0"/>
			<param name="instruction_length" value="32"/>
			<param name="opcode_width" value="7"/>
			<param name="x86" value="0"/>
			<param name="micro_opcode_width" value="0"/>
			<param name="machine_type" value="1"/>
			<!-- inorder/OoO; 1 inorder; 0 OOO-->
			<param name="number_hardware_threads" value="1"/>
			<!-- number_instruction_fetch_ports(icache ports) is always 1 in single-thread processor,
			it only may be more than one in SMT processors. BTB ports always equals to fetch ports since 
			branch information in consecutive branch instructions in the same fetch group can be read out from BTB once.--> 
			<param name="fetch_width" value="0"/>
			<!-- fetch_width determines the size of cachelines of L1 cache block -->
			<param name="number_instruction_fetch_ports" value="0"/>
			<param name="decode_width" value="0"/>
			<!-- decode_width determines the number of ports of the 
			renaming table (both RAM and CAM) scheme -->
			<param name="issue_width" value="0"/>
			<param name="peak_issue_width" value="0"/>
			<!-- issue_width determines the number of ports of Issue window and other logic 
			as in the complexity effective processors paper; issue_width==dispatch_width -->
			<param name="commit_width" value="0"/>
			<!-- commit_width determines the number of ports of register files -->
			<param name="fp_issue_width" value="0"/>
			<param name="prediction_width" value="0"/> 
			<!-- number of branch instructions can be predicted simultaneously-->
			<!-- Current version of McPAT does not distinguish int and floating point pipelines 
			Theses parameters are reserved for future use.--> 
			<param name="pipelines_per_core" value="0,0"/>
			<!--integer_pipeline and floating_pipelines, if the floating_pipelines is 0, then the pipeline is shared-->
			<param name="pipeline_depth" value="0,0"/>
			<!-- pipeline depth of int and fp, if pipeline is shared, the second number is the average cycles of fp ops -->
			<!-- issue and exe unit-->
			<param name="ALU_per_core" value="1"/>
			<!-- contains an adder, a shifter, and a logical unit -->
			<param name="MUL_per_core" value="0"/>
			<!-- For MUL and Div -->
			<param name="FPU_per_core" value="0"/>		
			<!-- buffer between IF and ID stage -->
			<param name="instruction_buffer_size" value="0"/>
			<!-- buffer between ID and sche/exe stage -->
			<param name="decoded_stream_buffer_size" value="0"/>
			<param name="instruction_window_scheme" value="0"/><!-- 0 PHYREG based, 1 RSBASED-->
			<!-- McPAT support 2 types of OoO cores, RS based and physical reg based-->
			<param name="instruction_window_size" value="0"/>
			<param name="fp_instruction_window_size" value="0"/>
			<!-- Numbers need to be confirmed -->
			<!-- the instruction issue Q as in Alpha 21264; The RS as in Intel P6 -->
			<param name="ROB_size" value="0"/>
			<!-- each in-flight instruction has an entry in ROB -->
			<!-- registers -->
			<param name="archi_Regs_IRF_size" value="0"/>			
			<param name="archi_Regs_FRF_size" value="0"/>
			<!--  if OoO processor, phy_reg number is needed for renaming logic, 
			renaming logic is for both integer and floating point insts.  -->
			<param name="phy_Regs_IRF_size" value="0"/>
			<param name="phy_Regs_FRF_size" value="0"/>
			<!-- rename logic -->
			<param name="rename_scheme" value="0"/>
			<!-- can be RAM based(0) or CAM based(1) rename scheme 
			RAM-based scheme will have free list, status table;
			CAM-based scheme have the valid bit in the data field of the CAM -->
			<param name="checkpoint_depth" value="0"/>
			<!-- RAM and CAM RAT contains checkpoints, checkpoint_depth=# of in_flight speculations;
			RAM-based RAT should not have more than 4 GCs (e.g., MIPS R10000). 
			McPAT assumes the exsistance of RRAT when the RAM-RAT having no GCs (e.g., Netburst)
			CAM-based RAT should have at least 1 GC and can have more than 8 GCs. -->
			<param name="register_windows_size" value="0"/>
			<!-- how many windows in the windowed register file, sun processors;
			no register windowing is used when this number is 0 -->
			<!-- In OoO cores, loads and stores can be issued whether inorder(Pentium Pro) or (OoO)out-of-order(Alpha),
			They will always try to execute out-of-order though. -->
			<param name="LSU_order" value="inorder"/>
			<param name="store_buffer_size" value="0"/>
			<!-- By default, in-order cores do not have load buffers -->
			<param name="load_buffer_size" value="0"/>	
			<!-- number of ports refer to sustain-able concurrent memory accesses --> 
			<param name="memory_ports" value="0"/>	
			<!-- max_allowed_in_flight_memo_instructions determines the # of ports of load and store buffer
			as well as the ports of Dcache which is connected to LSU -->	
			<!-- dual-pumped Dcache can be used to save the extra read/write ports -->
			<param name="RAS_size" value="0"/>						
			<!-- general stats, defines simulation periods;require total, idle, and busy cycles for sanity check  -->
			<!-- please note: if target architecture is X86, then all the instructions refer to (fused) micro-ops -->
			<stat name="total_instructions" value="30752"/>
			<stat name="int_instructions" value="30752"/>
			<stat name="fp_instructions" value="0"/>
			<stat name="branch_instructions" value="0"/>
			<stat name="branch_mispredictions" value="0"/>
			<stat name="load_instructions" value="0"/>
			<stat name="store_instructions" value="0"/>
			<stat name="committed_instructions" value="0"/>
			<stat name="committed_int_instructions" value="0"/>
			<stat name="committed_fp_instructions" value="0"/>
			<stat name="pipeline_duty_cycle" value="1"/><!--<=1, runtime_ipc/peak_ipc; averaged for all cores if homogeneous -->
			<!-- the following cycle stats are used for heterogeneous cores only, 
				please ignore them if homogeneous cores -->
			<stat name="total_cycles" value="2660804"/>
			<stat name="idle_cycles" value="2630052"/>
			<stat name="busy_cycles"  value="30752"/>
			<!-- instruction buffer stats -->
			<!-- ROB stats, both RS and Phy based OoOs have ROB
			performance simulator should capture the difference on accesses,
			otherwise, McPAT has to guess based on number of committed instructions. -->
			<stat name="ROB_reads" value="0"/>
			<stat name="ROB_writes" value="0"/>
			<!-- RAT accesses -->
			<stat name="rename_reads" value="0"/> <!--lookup in renaming logic -->
			<stat name="rename_writes" value="0"/><!--update dest regs. renaming logic -->
			<stat name="fp_rename_reads" value="0"/>
			<stat name="fp_rename_writes" value="0"/>
			<!-- decode and rename stage use this, should be total ic - nop -->
			<!-- Inst window stats -->
			<stat name="inst_window_reads" value="0"/>
			<stat name="inst_window_writes" value="0"/>
			<stat name="inst_window_wakeup_accesses" value="0"/>
			<stat name="fp_inst_window_reads" value="0"/>
			<stat name="fp_inst_window_writes" value="0"/>
			<stat name="fp_inst_window_wakeup_accesses" value="0"/>
			<!--  RF accesses -->
			<stat name="int_regfile_reads" value="0"/>
			<stat name="float_regfile_reads" value="0"/>
			<stat name="int_regfile_writes" value="0"/>
			<stat name="float_regfile_writes" value="0"/>
			<!-- accesses to the working reg -->
			<stat name="function_calls" value="0"/>
			<stat name="context_switches" value="0"/>
			<!-- Number of Windows switches (number of function calls and returns)-->
			<!-- Alu stats by default, the processor has one FPU that includes the divider and 
			 multiplier. The fpu accesses should include accesses to multiplier and divider  -->
			<stat name="ialu_accesses" value="30752"/>			
			<stat name="fpu_accesses" value="0"/>
			<stat name="mul_accesses" value="0"/>
			<stat name="cdb_alu_accesses" value="0"/>
			<stat name="cdb_mul_accesses" value="0"/>
			<stat name="cdb_fpu_accesses" value="0"/>
			<!-- multiple cycle accesses should be counted multiple times, 
			otherwise, McPAT can use internal counter for different floating point instructions 
			to get final accesses. But that needs detailed info for floating point inst mix -->
			<!--  currently the performance simulator should 
			make sure all the numbers are final numbers, 
			including the explicit read/write accesses, 
			and the implicit accesses such as replacements and etc.
			Future versions of McPAT may be able to reason the implicit access
			based on param and stats of last level cache
			The same rule applies to all cache access stats too!  -->
			<!-- following is AF for max power computation. 
				Do not change them, unless you understand them-->
			<stat name="IFU_duty_cycle" value="0.9"/>
			<stat name="BR_duty_cycle" value="0.72"/><!--branch-->			
			<stat name="LSU_duty_cycle" value="0.71"/>
			<stat name="MemManU_I_duty_cycle" value="0.9"/>
			<stat name="MemManU_D_duty_cycle" value="0.71"/>
			<stat name="ALU_duty_cycle" value="0.76"/>
			<!-- (.78*2+.71)/3 -->
			<stat name="MUL_duty_cycle" value="0.82"/>
			<stat name="FPU_duty_cycle" value="0.0"/>
			<stat name="ALU_cdb_duty_cycle" value="0.76"/>
			<stat name="MUL_cdb_duty_cycle" value="0.82"/>
			<stat name="FPU_cdb_duty_cycle" value="0.0"/>
		</component>
		<component id="system.core8" name="core8">
			<!-- Core property -->
			<param name="clock_rate" value="5"/>
			<!-- for cores with unknown timing, set to 0 to force off the opt flag -->
			<param name="opt_local" value="0"/>
			<param name="instruction_length" value="32"/>
			<param name="opcode_width" value="7"/>
			<param name="x86" value="0"/>
			<param name="micro_opcode_width" value="0"/>
			<param name="machine_type" value="1"/>
			<!-- inorder/OoO; 1 inorder; 0 OOO-->
			<param name="number_hardware_threads" value="1"/>
			<!-- number_instruction_fetch_ports(icache ports) is always 1 in single-thread processor,
			it only may be more than one in SMT processors. BTB ports always equals to fetch ports since 
			branch information in consecutive branch instructions in the same fetch group can be read out from BTB once.--> 
			<param name="fetch_width" value="0"/>
			<!-- fetch_width determines the size of cachelines of L1 cache block -->
			<param name="number_instruction_fetch_ports" value="0"/>
			<param name="decode_width" value="0"/>
			<!-- decode_width determines the number of ports of the 
			renaming table (both RAM and CAM) scheme -->
			<param name="issue_width" value="0"/>
			<param name="peak_issue_width" value="0"/>
			<!-- issue_width determines the number of ports of Issue window and other logic 
			as in the complexity effective processors paper; issue_width==dispatch_width -->
			<param name="commit_width" value="0"/>
			<!-- commit_width determines the number of ports of register files -->
			<param name="fp_issue_width" value="0"/>
			<param name="prediction_width" value="0"/> 
			<!-- number of branch instructions can be predicted simultaneously-->
			<!-- Current version of McPAT does not distinguish int and floating point pipelines 
			Theses parameters are reserved for future use.--> 
			<param name="pipelines_per_core" value="0,0"/>
			<!--integer_pipeline and floating_pipelines, if the floating_pipelines is 0, then the pipeline is shared-->
			<param name="pipeline_depth" value="0,0"/>
			<!-- pipeline depth of int and fp, if pipeline is shared, the second number is the average cycles of fp ops -->
			<!-- issue and exe unit-->
			<param name="ALU_per_core" value="1"/>
			<!-- contains an adder, a shifter, and a logical unit -->
			<param name="MUL_per_core" value="0"/>
			<!-- For MUL and Div -->
			<param name="FPU_per_core" value="0"/>		
			<!-- buffer between IF and ID stage -->
			<param name="instruction_buffer_size" value="0"/>
			<!-- buffer between ID and sche/exe stage -->
			<param name="decoded_stream_buffer_size" value="0"/>
			<param name="instruction_window_scheme" value="0"/><!-- 0 PHYREG based, 1 RSBASED-->
			<!-- McPAT support 2 types of OoO cores, RS based and physical reg based-->
			<param name="instruction_window_size" value="0"/>
			<param name="fp_instruction_window_size" value="0"/>
			<!-- Numbers need to be confirmed -->
			<!-- the instruction issue Q as in Alpha 21264; The RS as in Intel P6 -->
			<param name="ROB_size" value="0"/>
			<!-- each in-flight instruction has an entry in ROB -->
			<!-- registers -->
			<param name="archi_Regs_IRF_size" value="0"/>			
			<param name="archi_Regs_FRF_size" value="0"/>
			<!--  if OoO processor, phy_reg number is needed for renaming logic, 
			renaming logic is for both integer and floating point insts.  -->
			<param name="phy_Regs_IRF_size" value="0"/>
			<param name="phy_Regs_FRF_size" value="0"/>
			<!-- rename logic -->
			<param name="rename_scheme" value="0"/>
			<!-- can be RAM based(0) or CAM based(1) rename scheme 
			RAM-based scheme will have free list, status table;
			CAM-based scheme have the valid bit in the data field of the CAM -->
			<param name="checkpoint_depth" value="0"/>
			<!-- RAM and CAM RAT contains checkpoints, checkpoint_depth=# of in_flight speculations;
			RAM-based RAT should not have more than 4 GCs (e.g., MIPS R10000). 
			McPAT assumes the exsistance of RRAT when the RAM-RAT having no GCs (e.g., Netburst)
			CAM-based RAT should have at least 1 GC and can have more than 8 GCs. -->
			<param name="register_windows_size" value="0"/>
			<!-- how many windows in the windowed register file, sun processors;
			no register windowing is used when this number is 0 -->
			<!-- In OoO cores, loads and stores can be issued whether inorder(Pentium Pro) or (OoO)out-of-order(Alpha),
			They will always try to execute out-of-order though. -->
			<param name="LSU_order" value="inorder"/>
			<param name="store_buffer_size" value="0"/>
			<!-- By default, in-order cores do not have load buffers -->
			<param name="load_buffer_size" value="0"/>	
			<!-- number of ports refer to sustain-able concurrent memory accesses --> 
			<param name="memory_ports" value="0"/>	
			<!-- max_allowed_in_flight_memo_instructions determines the # of ports of load and store buffer
			as well as the ports of Dcache which is connected to LSU -->	
			<!-- dual-pumped Dcache can be used to save the extra read/write ports -->
			<param name="RAS_size" value="0"/>						
			<!-- general stats, defines simulation periods;require total, idle, and busy cycles for sanity check  -->
			<!-- please note: if target architecture is X86, then all the instructions refer to (fused) micro-ops -->
			<stat name="total_instructions" value="30752"/>
			<stat name="int_instructions" value="30752"/>
			<stat name="fp_instructions" value="0"/>
			<stat name="branch_instructions" value="0"/>
			<stat name="branch_mispredictions" value="0"/>
			<stat name="load_instructions" value="0"/>
			<stat name="store_instructions" value="0"/>
			<stat name="committed_instructions" value="0"/>
			<stat name="committed_int_instructions" value="0"/>
			<stat name="committed_fp_instructions" value="0"/>
			<stat name="pipeline_duty_cycle" value="1"/><!--<=1, runtime_ipc/peak_ipc; averaged for all cores if homogeneous -->
			<!-- the following cycle stats are used for heterogeneous cores only, 
				please ignore them if homogeneous cores -->
			<stat name="total_cycles" value="2660804"/>
			<stat name="idle_cycles" value="2630052"/>
			<stat name="busy_cycles"  value="30752"/>
			<!-- instruction buffer stats -->
			<!-- ROB stats, both RS and Phy based OoOs have ROB
			performance simulator should capture the difference on accesses,
			otherwise, McPAT has to guess based on number of committed instructions. -->
			<stat name="ROB_reads" value="0"/>
			<stat name="ROB_writes" value="0"/>
			<!-- RAT accesses -->
			<stat name="rename_reads" value="0"/> <!--lookup in renaming logic -->
			<stat name="rename_writes" value="0"/><!--update dest regs. renaming logic -->
			<stat name="fp_rename_reads" value="0"/>
			<stat name="fp_rename_writes" value="0"/>
			<!-- decode and rename stage use this, should be total ic - nop -->
			<!-- Inst window stats -->
			<stat name="inst_window_reads" value="0"/>
			<stat name="inst_window_writes" value="0"/>
			<stat name="inst_window_wakeup_accesses" value="0"/>
			<stat name="fp_inst_window_reads" value="0"/>
			<stat name="fp_inst_window_writes" value="0"/>
			<stat name="fp_inst_window_wakeup_accesses" value="0"/>
			<!--  RF accesses -->
			<stat name="int_regfile_reads" value="0"/>
			<stat name="float_regfile_reads" value="0"/>
			<stat name="int_regfile_writes" value="0"/>
			<stat name="float_regfile_writes" value="0"/>
			<!-- accesses to the working reg -->
			<stat name="function_calls" value="0"/>
			<stat name="context_switches" value="0"/>
			<!-- Number of Windows switches (number of function calls and returns)-->
			<!-- Alu stats by default, the processor has one FPU that includes the divider and 
			 multiplier. The fpu accesses should include accesses to multiplier and divider  -->
			<stat name="ialu_accesses" value="30752"/>			
			<stat name="fpu_accesses" value="0"/>
			<stat name="mul_accesses" value="0"/>
			<stat name="cdb_alu_accesses" value="0"/>
			<stat name="cdb_mul_accesses" value="0"/>
			<stat name="cdb_fpu_accesses" value="0"/>
			<!-- multiple cycle accesses should be counted multiple times, 
			otherwise, McPAT can use internal counter for different floating point instructions 
			to get final accesses. But that needs detailed info for floating point inst mix -->
			<!--  currently the performance simulator should 
			make sure all the numbers are final numbers, 
			including the explicit read/write accesses, 
			and the implicit accesses such as replacements and etc.
			Future versions of McPAT may be able to reason the implicit access
			based on param and stats of last level cache
			The same rule applies to all cache access stats too!  -->
			<!-- following is AF for max power computation. 
				Do not change them, unless you understand them-->
			<stat name="IFU_duty_cycle" value="0.9"/>
			<stat name="BR_duty_cycle" value="0.72"/><!--branch-->			
			<stat name="LSU_duty_cycle" value="0.71"/>
			<stat name="MemManU_I_duty_cycle" value="0.9"/>
			<stat name="MemManU_D_duty_cycle" value="0.71"/>
			<stat name="ALU_duty_cycle" value="0.76"/>
			<!-- (.78*2+.71)/3 -->
			<stat name="MUL_duty_cycle" value="0.82"/>
			<stat name="FPU_duty_cycle" value="0.0"/>
			<stat name="ALU_cdb_duty_cycle" value="0.76"/>
			<stat name="MUL_cdb_duty_cycle" value="0.82"/>
			<stat name="FPU_cdb_duty_cycle" value="0.0"/>
		</component>
		<component id="system.core9" name="core9">
			<!-- Core property -->
			<param name="clock_rate" value="5"/>
			<!-- for cores with unknown timing, set to 0 to force off the opt flag -->
			<param name="opt_local" value="0"/>
			<param name="instruction_length" value="32"/>
			<param name="opcode_width" value="7"/>
			<param name="x86" value="0"/>
			<param name="micro_opcode_width" value="0"/>
			<param name="machine_type" value="1"/>
			<!-- inorder/OoO; 1 inorder; 0 OOO-->
			<param name="number_hardware_threads" value="1"/>
			<!-- number_instruction_fetch_ports(icache ports) is always 1 in single-thread processor,
			it only may be more than one in SMT processors. BTB ports always equals to fetch ports since 
			branch information in consecutive branch instructions in the same fetch group can be read out from BTB once.--> 
			<param name="fetch_width" value="0"/>
			<!-- fetch_width determines the size of cachelines of L1 cache block -->
			<param name="number_instruction_fetch_ports" value="0"/>
			<param name="decode_width" value="0"/>
			<!-- decode_width determines the number of ports of the 
			renaming table (both RAM and CAM) scheme -->
			<param name="issue_width" value="0"/>
			<param name="peak_issue_width" value="0"/>
			<!-- issue_width determines the number of ports of Issue window and other logic 
			as in the complexity effective processors paper; issue_width==dispatch_width -->
			<param name="commit_width" value="0"/>
			<!-- commit_width determines the number of ports of register files -->
			<param name="fp_issue_width" value="0"/>
			<param name="prediction_width" value="0"/> 
			<!-- number of branch instructions can be predicted simultaneously-->
			<!-- Current version of McPAT does not distinguish int and floating point pipelines 
			Theses parameters are reserved for future use.--> 
			<param name="pipelines_per_core" value="0,0"/>
			<!--integer_pipeline and floating_pipelines, if the floating_pipelines is 0, then the pipeline is shared-->
			<param name="pipeline_depth" value="0,0"/>
			<!-- pipeline depth of int and fp, if pipeline is shared, the second number is the average cycles of fp ops -->
			<!-- issue and exe unit-->
			<param name="ALU_per_core" value="1"/>
			<!-- contains an adder, a shifter, and a logical unit -->
			<param name="MUL_per_core" value="0"/>
			<!-- For MUL and Div -->
			<param name="FPU_per_core" value="0"/>		
			<!-- buffer between IF and ID stage -->
			<param name="instruction_buffer_size" value="0"/>
			<!-- buffer between ID and sche/exe stage -->
			<param name="decoded_stream_buffer_size" value="0"/>
			<param name="instruction_window_scheme" value="0"/><!-- 0 PHYREG based, 1 RSBASED-->
			<!-- McPAT support 2 types of OoO cores, RS based and physical reg based-->
			<param name="instruction_window_size" value="0"/>
			<param name="fp_instruction_window_size" value="0"/>
			<!-- Numbers need to be confirmed -->
			<!-- the instruction issue Q as in Alpha 21264; The RS as in Intel P6 -->
			<param name="ROB_size" value="0"/>
			<!-- each in-flight instruction has an entry in ROB -->
			<!-- registers -->
			<param name="archi_Regs_IRF_size" value="0"/>			
			<param name="archi_Regs_FRF_size" value="0"/>
			<!--  if OoO processor, phy_reg number is needed for renaming logic, 
			renaming logic is for both integer and floating point insts.  -->
			<param name="phy_Regs_IRF_size" value="0"/>
			<param name="phy_Regs_FRF_size" value="0"/>
			<!-- rename logic -->
			<param name="rename_scheme" value="0"/>
			<!-- can be RAM based(0) or CAM based(1) rename scheme 
			RAM-based scheme will have free list, status table;
			CAM-based scheme have the valid bit in the data field of the CAM -->
			<param name="checkpoint_depth" value="0"/>
			<!-- RAM and CAM RAT contains checkpoints, checkpoint_depth=# of in_flight speculations;
			RAM-based RAT should not have more than 4 GCs (e.g., MIPS R10000). 
			McPAT assumes the exsistance of RRAT when the RAM-RAT having no GCs (e.g., Netburst)
			CAM-based RAT should have at least 1 GC and can have more than 8 GCs. -->
			<param name="register_windows_size" value="0"/>
			<!-- how many windows in the windowed register file, sun processors;
			no register windowing is used when this number is 0 -->
			<!-- In OoO cores, loads and stores can be issued whether inorder(Pentium Pro) or (OoO)out-of-order(Alpha),
			They will always try to execute out-of-order though. -->
			<param name="LSU_order" value="inorder"/>
			<param name="store_buffer_size" value="0"/>
			<!-- By default, in-order cores do not have load buffers -->
			<param name="load_buffer_size" value="0"/>	
			<!-- number of ports refer to sustain-able concurrent memory accesses --> 
			<param name="memory_ports" value="0"/>	
			<!-- max_allowed_in_flight_memo_instructions determines the # of ports of load and store buffer
			as well as the ports of Dcache which is connected to LSU -->	
			<!-- dual-pumped Dcache can be used to save the extra read/write ports -->
			<param name="RAS_size" value="0"/>						
			<!-- general stats, defines simulation periods;require total, idle, and busy cycles for sanity check  -->
			<!-- please note: if target architecture is X86, then all the instructions refer to (fused) micro-ops -->
			<stat name="total_instructions" value="0"/>
			<stat name="int_instructions" value="0"/>
			<stat name="fp_instructions" value="0"/>
			<stat name="branch_instructions" value="0"/>
			<stat name="branch_mispredictions" value="0"/>
			<stat name="load_instructions" value="0"/>
			<stat name="store_instructions" value="0"/>
			<stat name="committed_instructions" value="0"/>
			<stat name="committed_int_instructions" value="0"/>
			<stat name="committed_fp_instructions" value="0"/>
			<stat name="pipeline_duty_cycle" value="1"/><!--<=1, runtime_ipc/peak_ipc; averaged for all cores if homogeneous -->
			<!-- the following cycle stats are used for heterogeneous cores only, 
				please ignore them if homogeneous cores -->
			<stat name="total_cycles" value="2660804"/>
			<stat name="idle_cycles" value="2660804"/>
			<stat name="busy_cycles"  value="0"/>
			<!-- instruction buffer stats -->
			<!-- ROB stats, both RS and Phy based OoOs have ROB
			performance simulator should capture the difference on accesses,
			otherwise, McPAT has to guess based on number of committed instructions. -->
			<stat name="ROB_reads" value="0"/>
			<stat name="ROB_writes" value="0"/>
			<!-- RAT accesses -->
			<stat name="rename_reads" value="0"/> <!--lookup in renaming logic -->
			<stat name="rename_writes" value="0"/><!--update dest regs. renaming logic -->
			<stat name="fp_rename_reads" value="0"/>
			<stat name="fp_rename_writes" value="0"/>
			<!-- decode and rename stage use this, should be total ic - nop -->
			<!-- Inst window stats -->
			<stat name="inst_window_reads" value="0"/>
			<stat name="inst_window_writes" value="0"/>
			<stat name="inst_window_wakeup_accesses" value="0"/>
			<stat name="fp_inst_window_reads" value="0"/>
			<stat name="fp_inst_window_writes" value="0"/>
			<stat name="fp_inst_window_wakeup_accesses" value="0"/>
			<!--  RF accesses -->
			<stat name="int_regfile_reads" value="0"/>
			<stat name="float_regfile_reads" value="0"/>
			<stat name="int_regfile_writes" value="0"/>
			<stat name="float_regfile_writes" value="0"/>
			<!-- accesses to the working reg -->
			<stat name="function_calls" value="0"/>
			<stat name="context_switches" value="0"/>
			<!-- Number of Windows switches (number of function calls and returns)-->
			<!-- Alu stats by default, the processor has one FPU that includes the divider and 
			 multiplier. The fpu accesses should include accesses to multiplier and divider  -->
			<stat name="ialu_accesses" value="0"/>			
			<stat name="fpu_accesses" value="0"/>
			<stat name="mul_accesses" value="0"/>
			<stat name="cdb_alu_accesses" value="0"/>
			<stat name="cdb_mul_accesses" value="0"/>
			<stat name="cdb_fpu_accesses" value="0"/>
			<!-- multiple cycle accesses should be counted multiple times, 
			otherwise, McPAT can use internal counter for different floating point instructions 
			to get final accesses. But that needs detailed info for floating point inst mix -->
			<!--  currently the performance simulator should 
			make sure all the numbers are final numbers, 
			including the explicit read/write accesses, 
			and the implicit accesses such as replacements and etc.
			Future versions of McPAT may be able to reason the implicit access
			based on param and stats of last level cache
			The same rule applies to all cache access stats too!  -->
			<!-- following is AF for max power computation. 
				Do not change them, unless you understand them-->
			<stat name="IFU_duty_cycle" value="0.9"/>
			<stat name="BR_duty_cycle" value="0.72"/><!--branch-->			
			<stat name="LSU_duty_cycle" value="0.71"/>
			<stat name="MemManU_I_duty_cycle" value="0.9"/>
			<stat name="MemManU_D_duty_cycle" value="0.71"/>
			<stat name="ALU_duty_cycle" value="0.76"/>
			<!-- (.78*2+.71)/3 -->
			<stat name="MUL_duty_cycle" value="0.82"/>
			<stat name="FPU_duty_cycle" value="0.0"/>
			<stat name="ALU_cdb_duty_cycle" value="0.76"/>
			<stat name="MUL_cdb_duty_cycle" value="0.82"/>
			<stat name="FPU_cdb_duty_cycle" value="0.0"/>
		</component>
		<component id="system.core10" name="core10">
			<!-- Core property -->
			<param name="clock_rate" value="5"/>
			<!-- for cores with unknown timing, set to 0 to force off the opt flag -->
			<param name="opt_local" value="0"/>
			<param name="instruction_length" value="32"/>
			<param name="opcode_width" value="7"/>
			<param name="x86" value="0"/>
			<param name="micro_opcode_width" value="0"/>
			<param name="machine_type" value="1"/>
			<!-- inorder/OoO; 1 inorder; 0 OOO-->
			<param name="number_hardware_threads" value="1"/>
			<!-- number_instruction_fetch_ports(icache ports) is always 1 in single-thread processor,
			it only may be more than one in SMT processors. BTB ports always equals to fetch ports since 
			branch information in consecutive branch instructions in the same fetch group can be read out from BTB once.--> 
			<param name="fetch_width" value="0"/>
			<!-- fetch_width determines the size of cachelines of L1 cache block -->
			<param name="number_instruction_fetch_ports" value="0"/>
			<param name="decode_width" value="0"/>
			<!-- decode_width determines the number of ports of the 
			renaming table (both RAM and CAM) scheme -->
			<param name="issue_width" value="0"/>
			<param name="peak_issue_width" value="0"/>
			<!-- issue_width determines the number of ports of Issue window and other logic 
			as in the complexity effective processors paper; issue_width==dispatch_width -->
			<param name="commit_width" value="0"/>
			<!-- commit_width determines the number of ports of register files -->
			<param name="fp_issue_width" value="0"/>
			<param name="prediction_width" value="0"/> 
			<!-- number of branch instructions can be predicted simultaneously-->
			<!-- Current version of McPAT does not distinguish int and floating point pipelines 
			Theses parameters are reserved for future use.--> 
			<param name="pipelines_per_core" value="0,0"/>
			<!--integer_pipeline and floating_pipelines, if the floating_pipelines is 0, then the pipeline is shared-->
			<param name="pipeline_depth" value="0,0"/>
			<!-- pipeline depth of int and fp, if pipeline is shared, the second number is the average cycles of fp ops -->
			<!-- issue and exe unit-->
			<param name="ALU_per_core" value="1"/>
			<!-- contains an adder, a shifter, and a logical unit -->
			<param name="MUL_per_core" value="0"/>
			<!-- For MUL and Div -->
			<param name="FPU_per_core" value="0"/>		
			<!-- buffer between IF and ID stage -->
			<param name="instruction_buffer_size" value="0"/>
			<!-- buffer between ID and sche/exe stage -->
			<param name="decoded_stream_buffer_size" value="0"/>
			<param name="instruction_window_scheme" value="0"/><!-- 0 PHYREG based, 1 RSBASED-->
			<!-- McPAT support 2 types of OoO cores, RS based and physical reg based-->
			<param name="instruction_window_size" value="0"/>
			<param name="fp_instruction_window_size" value="0"/>
			<!-- Numbers need to be confirmed -->
			<!-- the instruction issue Q as in Alpha 21264; The RS as in Intel P6 -->
			<param name="ROB_size" value="0"/>
			<!-- each in-flight instruction has an entry in ROB -->
			<!-- registers -->
			<param name="archi_Regs_IRF_size" value="0"/>			
			<param name="archi_Regs_FRF_size" value="0"/>
			<!--  if OoO processor, phy_reg number is needed for renaming logic, 
			renaming logic is for both integer and floating point insts.  -->
			<param name="phy_Regs_IRF_size" value="0"/>
			<param name="phy_Regs_FRF_size" value="0"/>
			<!-- rename logic -->
			<param name="rename_scheme" value="0"/>
			<!-- can be RAM based(0) or CAM based(1) rename scheme 
			RAM-based scheme will have free list, status table;
			CAM-based scheme have the valid bit in the data field of the CAM -->
			<param name="checkpoint_depth" value="0"/>
			<!-- RAM and CAM RAT contains checkpoints, checkpoint_depth=# of in_flight speculations;
			RAM-based RAT should not have more than 4 GCs (e.g., MIPS R10000). 
			McPAT assumes the exsistance of RRAT when the RAM-RAT having no GCs (e.g., Netburst)
			CAM-based RAT should have at least 1 GC and can have more than 8 GCs. -->
			<param name="register_windows_size" value="0"/>
			<!-- how many windows in the windowed register file, sun processors;
			no register windowing is used when this number is 0 -->
			<!-- In OoO cores, loads and stores can be issued whether inorder(Pentium Pro) or (OoO)out-of-order(Alpha),
			They will always try to execute out-of-order though. -->
			<param name="LSU_order" value="inorder"/>
			<param name="store_buffer_size" value="0"/>
			<!-- By default, in-order cores do not have load buffers -->
			<param name="load_buffer_size" value="0"/>	
			<!-- number of ports refer to sustain-able concurrent memory accesses --> 
			<param name="memory_ports" value="0"/>	
			<!-- max_allowed_in_flight_memo_instructions determines the # of ports of load and store buffer
			as well as the ports of Dcache which is connected to LSU -->	
			<!-- dual-pumped Dcache can be used to save the extra read/write ports -->
			<param name="RAS_size" value="0"/>						
			<!-- general stats, defines simulation periods;require total, idle, and busy cycles for sanity check  -->
			<!-- please note: if target architecture is X86, then all the instructions refer to (fused) micro-ops -->
			<stat name="total_instructions" value="23064"/>
			<stat name="int_instructions" value="23064"/>
			<stat name="fp_instructions" value="0"/>
			<stat name="branch_instructions" value="0"/>
			<stat name="branch_mispredictions" value="0"/>
			<stat name="load_instructions" value="0"/>
			<stat name="store_instructions" value="0"/>
			<stat name="committed_instructions" value="0"/>
			<stat name="committed_int_instructions" value="0"/>
			<stat name="committed_fp_instructions" value="0"/>
			<stat name="pipeline_duty_cycle" value="1"/><!--<=1, runtime_ipc/peak_ipc; averaged for all cores if homogeneous -->
			<!-- the following cycle stats are used for heterogeneous cores only, 
				please ignore them if homogeneous cores -->
			<stat name="total_cycles" value="2660804"/>
			<stat name="idle_cycles" value="2637740"/>
			<stat name="busy_cycles"  value="23064"/>
			<!-- instruction buffer stats -->
			<!-- ROB stats, both RS and Phy based OoOs have ROB
			performance simulator should capture the difference on accesses,
			otherwise, McPAT has to guess based on number of committed instructions. -->
			<stat name="ROB_reads" value="0"/>
			<stat name="ROB_writes" value="0"/>
			<!-- RAT accesses -->
			<stat name="rename_reads" value="0"/> <!--lookup in renaming logic -->
			<stat name="rename_writes" value="0"/><!--update dest regs. renaming logic -->
			<stat name="fp_rename_reads" value="0"/>
			<stat name="fp_rename_writes" value="0"/>
			<!-- decode and rename stage use this, should be total ic - nop -->
			<!-- Inst window stats -->
			<stat name="inst_window_reads" value="0"/>
			<stat name="inst_window_writes" value="0"/>
			<stat name="inst_window_wakeup_accesses" value="0"/>
			<stat name="fp_inst_window_reads" value="0"/>
			<stat name="fp_inst_window_writes" value="0"/>
			<stat name="fp_inst_window_wakeup_accesses" value="0"/>
			<!--  RF accesses -->
			<stat name="int_regfile_reads" value="0"/>
			<stat name="float_regfile_reads" value="0"/>
			<stat name="int_regfile_writes" value="0"/>
			<stat name="float_regfile_writes" value="0"/>
			<!-- accesses to the working reg -->
			<stat name="function_calls" value="0"/>
			<stat name="context_switches" value="0"/>
			<!-- Number of Windows switches (number of function calls and returns)-->
			<!-- Alu stats by default, the processor has one FPU that includes the divider and 
			 multiplier. The fpu accesses should include accesses to multiplier and divider  -->
			<stat name="ialu_accesses" value="23064"/>			
			<stat name="fpu_accesses" value="0"/>
			<stat name="mul_accesses" value="0"/>
			<stat name="cdb_alu_accesses" value="0"/>
			<stat name="cdb_mul_accesses" value="0"/>
			<stat name="cdb_fpu_accesses" value="0"/>
			<!-- multiple cycle accesses should be counted multiple times, 
			otherwise, McPAT can use internal counter for different floating point instructions 
			to get final accesses. But that needs detailed info for floating point inst mix -->
			<!--  currently the performance simulator should 
			make sure all the numbers are final numbers, 
			including the explicit read/write accesses, 
			and the implicit accesses such as replacements and etc.
			Future versions of McPAT may be able to reason the implicit access
			based on param and stats of last level cache
			The same rule applies to all cache access stats too!  -->
			<!-- following is AF for max power computation. 
				Do not change them, unless you understand them-->
			<stat name="IFU_duty_cycle" value="0.9"/>
			<stat name="BR_duty_cycle" value="0.72"/><!--branch-->			
			<stat name="LSU_duty_cycle" value="0.71"/>
			<stat name="MemManU_I_duty_cycle" value="0.9"/>
			<stat name="MemManU_D_duty_cycle" value="0.71"/>
			<stat name="ALU_duty_cycle" value="0.76"/>
			<!-- (.78*2+.71)/3 -->
			<stat name="MUL_duty_cycle" value="0.82"/>
			<stat name="FPU_duty_cycle" value="0.0"/>
			<stat name="ALU_cdb_duty_cycle" value="0.76"/>
			<stat name="MUL_cdb_duty_cycle" value="0.82"/>
			<stat name="FPU_cdb_duty_cycle" value="0.0"/>
		</component>
		<component id="system.core11" name="core11">
			<!-- Core property -->
			<param name="clock_rate" value="5"/>
			<!-- for cores with unknown timing, set to 0 to force off the opt flag -->
			<param name="opt_local" value="0"/>
			<param name="instruction_length" value="32"/>
			<param name="opcode_width" value="7"/>
			<param name="x86" value="0"/>
			<param name="micro_opcode_width" value="0"/>
			<param name="machine_type" value="1"/>
			<!-- inorder/OoO; 1 inorder; 0 OOO-->
			<param name="number_hardware_threads" value="1"/>
			<!-- number_instruction_fetch_ports(icache ports) is always 1 in single-thread processor,
			it only may be more than one in SMT processors. BTB ports always equals to fetch ports since 
			branch information in consecutive branch instructions in the same fetch group can be read out from BTB once.--> 
			<param name="fetch_width" value="0"/>
			<!-- fetch_width determines the size of cachelines of L1 cache block -->
			<param name="number_instruction_fetch_ports" value="0"/>
			<param name="decode_width" value="0"/>
			<!-- decode_width determines the number of ports of the 
			renaming table (both RAM and CAM) scheme -->
			<param name="issue_width" value="0"/>
			<param name="peak_issue_width" value="0"/>
			<!-- issue_width determines the number of ports of Issue window and other logic 
			as in the complexity effective processors paper; issue_width==dispatch_width -->
			<param name="commit_width" value="0"/>
			<!-- commit_width determines the number of ports of register files -->
			<param name="fp_issue_width" value="0"/>
			<param name="prediction_width" value="0"/> 
			<!-- number of branch instructions can be predicted simultaneously-->
			<!-- Current version of McPAT does not distinguish int and floating point pipelines 
			Theses parameters are reserved for future use.--> 
			<param name="pipelines_per_core" value="0,0"/>
			<!--integer_pipeline and floating_pipelines, if the floating_pipelines is 0, then the pipeline is shared-->
			<param name="pipeline_depth" value="0,0"/>
			<!-- pipeline depth of int and fp, if pipeline is shared, the second number is the average cycles of fp ops -->
			<!-- issue and exe unit-->
			<param name="ALU_per_core" value="1"/>
			<!-- contains an adder, a shifter, and a logical unit -->
			<param name="MUL_per_core" value="0"/>
			<!-- For MUL and Div -->
			<param name="FPU_per_core" value="0"/>		
			<!-- buffer between IF and ID stage -->
			<param name="instruction_buffer_size" value="0"/>
			<!-- buffer between ID and sche/exe stage -->
			<param name="decoded_stream_buffer_size" value="0"/>
			<param name="instruction_window_scheme" value="0"/><!-- 0 PHYREG based, 1 RSBASED-->
			<!-- McPAT support 2 types of OoO cores, RS based and physical reg based-->
			<param name="instruction_window_size" value="0"/>
			<param name="fp_instruction_window_size" value="0"/>
			<!-- Numbers need to be confirmed -->
			<!-- the instruction issue Q as in Alpha 21264; The RS as in Intel P6 -->
			<param name="ROB_size" value="0"/>
			<!-- each in-flight instruction has an entry in ROB -->
			<!-- registers -->
			<param name="archi_Regs_IRF_size" value="0"/>			
			<param name="archi_Regs_FRF_size" value="0"/>
			<!--  if OoO processor, phy_reg number is needed for renaming logic, 
			renaming logic is for both integer and floating point insts.  -->
			<param name="phy_Regs_IRF_size" value="0"/>
			<param name="phy_Regs_FRF_size" value="0"/>
			<!-- rename logic -->
			<param name="rename_scheme" value="0"/>
			<!-- can be RAM based(0) or CAM based(1) rename scheme 
			RAM-based scheme will have free list, status table;
			CAM-based scheme have the valid bit in the data field of the CAM -->
			<param name="checkpoint_depth" value="0"/>
			<!-- RAM and CAM RAT contains checkpoints, checkpoint_depth=# of in_flight speculations;
			RAM-based RAT should not have more than 4 GCs (e.g., MIPS R10000). 
			McPAT assumes the exsistance of RRAT when the RAM-RAT having no GCs (e.g., Netburst)
			CAM-based RAT should have at least 1 GC and can have more than 8 GCs. -->
			<param name="register_windows_size" value="0"/>
			<!-- how many windows in the windowed register file, sun processors;
			no register windowing is used when this number is 0 -->
			<!-- In OoO cores, loads and stores can be issued whether inorder(Pentium Pro) or (OoO)out-of-order(Alpha),
			They will always try to execute out-of-order though. -->
			<param name="LSU_order" value="inorder"/>
			<param name="store_buffer_size" value="0"/>
			<!-- By default, in-order cores do not have load buffers -->
			<param name="load_buffer_size" value="0"/>	
			<!-- number of ports refer to sustain-able concurrent memory accesses --> 
			<param name="memory_ports" value="0"/>	
			<!-- max_allowed_in_flight_memo_instructions determines the # of ports of load and store buffer
			as well as the ports of Dcache which is connected to LSU -->	
			<!-- dual-pumped Dcache can be used to save the extra read/write ports -->
			<param name="RAS_size" value="0"/>						
			<!-- general stats, defines simulation periods;require total, idle, and busy cycles for sanity check  -->
			<!-- please note: if target architecture is X86, then all the instructions refer to (fused) micro-ops -->
			<stat name="total_instructions" value="46128"/>
			<stat name="int_instructions" value="46128"/>
			<stat name="fp_instructions" value="0"/>
			<stat name="branch_instructions" value="0"/>
			<stat name="branch_mispredictions" value="0"/>
			<stat name="load_instructions" value="0"/>
			<stat name="store_instructions" value="0"/>
			<stat name="committed_instructions" value="0"/>
			<stat name="committed_int_instructions" value="0"/>
			<stat name="committed_fp_instructions" value="0"/>
			<stat name="pipeline_duty_cycle" value="1"/><!--<=1, runtime_ipc/peak_ipc; averaged for all cores if homogeneous -->
			<!-- the following cycle stats are used for heterogeneous cores only, 
				please ignore them if homogeneous cores -->
			<stat name="total_cycles" value="2660804"/>
			<stat name="idle_cycles" value="2614676"/>
			<stat name="busy_cycles"  value="46128"/>
			<!-- instruction buffer stats -->
			<!-- ROB stats, both RS and Phy based OoOs have ROB
			performance simulator should capture the difference on accesses,
			otherwise, McPAT has to guess based on number of committed instructions. -->
			<stat name="ROB_reads" value="0"/>
			<stat name="ROB_writes" value="0"/>
			<!-- RAT accesses -->
			<stat name="rename_reads" value="0"/> <!--lookup in renaming logic -->
			<stat name="rename_writes" value="0"/><!--update dest regs. renaming logic -->
			<stat name="fp_rename_reads" value="0"/>
			<stat name="fp_rename_writes" value="0"/>
			<!-- decode and rename stage use this, should be total ic - nop -->
			<!-- Inst window stats -->
			<stat name="inst_window_reads" value="0"/>
			<stat name="inst_window_writes" value="0"/>
			<stat name="inst_window_wakeup_accesses" value="0"/>
			<stat name="fp_inst_window_reads" value="0"/>
			<stat name="fp_inst_window_writes" value="0"/>
			<stat name="fp_inst_window_wakeup_accesses" value="0"/>
			<!--  RF accesses -->
			<stat name="int_regfile_reads" value="0"/>
			<stat name="float_regfile_reads" value="0"/>
			<stat name="int_regfile_writes" value="0"/>
			<stat name="float_regfile_writes" value="0"/>
			<!-- accesses to the working reg -->
			<stat name="function_calls" value="0"/>
			<stat name="context_switches" value="0"/>
			<!-- Number of Windows switches (number of function calls and returns)-->
			<!-- Alu stats by default, the processor has one FPU that includes the divider and 
			 multiplier. The fpu accesses should include accesses to multiplier and divider  -->
			<stat name="ialu_accesses" value="46128"/>			
			<stat name="fpu_accesses" value="0"/>
			<stat name="mul_accesses" value="0"/>
			<stat name="cdb_alu_accesses" value="0"/>
			<stat name="cdb_mul_accesses" value="0"/>
			<stat name="cdb_fpu_accesses" value="0"/>
			<!-- multiple cycle accesses should be counted multiple times, 
			otherwise, McPAT can use internal counter for different floating point instructions 
			to get final accesses. But that needs detailed info for floating point inst mix -->
			<!--  currently the performance simulator should 
			make sure all the numbers are final numbers, 
			including the explicit read/write accesses, 
			and the implicit accesses such as replacements and etc.
			Future versions of McPAT may be able to reason the implicit access
			based on param and stats of last level cache
			The same rule applies to all cache access stats too!  -->
			<!-- following is AF for max power computation. 
				Do not change them, unless you understand them-->
			<stat name="IFU_duty_cycle" value="0.9"/>
			<stat name="BR_duty_cycle" value="0.72"/><!--branch-->			
			<stat name="LSU_duty_cycle" value="0.71"/>
			<stat name="MemManU_I_duty_cycle" value="0.9"/>
			<stat name="MemManU_D_duty_cycle" value="0.71"/>
			<stat name="ALU_duty_cycle" value="0.76"/>
			<!-- (.78*2+.71)/3 -->
			<stat name="MUL_duty_cycle" value="0.82"/>
			<stat name="FPU_duty_cycle" value="0.0"/>
			<stat name="ALU_cdb_duty_cycle" value="0.76"/>
			<stat name="MUL_cdb_duty_cycle" value="0.82"/>
			<stat name="FPU_cdb_duty_cycle" value="0.0"/>
		</component>
		<component id="system.core12" name="core12">
			<!-- Core property -->
			<param name="clock_rate" value="5"/>
			<!-- for cores with unknown timing, set to 0 to force off the opt flag -->
			<param name="opt_local" value="0"/>
			<param name="instruction_length" value="32"/>
			<param name="opcode_width" value="7"/>
			<param name="x86" value="0"/>
			<param name="micro_opcode_width" value="0"/>
			<param name="machine_type" value="1"/>
			<!-- inorder/OoO; 1 inorder; 0 OOO-->
			<param name="number_hardware_threads" value="1"/>
			<!-- number_instruction_fetch_ports(icache ports) is always 1 in single-thread processor,
			it only may be more than one in SMT processors. BTB ports always equals to fetch ports since 
			branch information in consecutive branch instructions in the same fetch group can be read out from BTB once.--> 
			<param name="fetch_width" value="0"/>
			<!-- fetch_width determines the size of cachelines of L1 cache block -->
			<param name="number_instruction_fetch_ports" value="0"/>
			<param name="decode_width" value="0"/>
			<!-- decode_width determines the number of ports of the 
			renaming table (both RAM and CAM) scheme -->
			<param name="issue_width" value="0"/>
			<param name="peak_issue_width" value="0"/>
			<!-- issue_width determines the number of ports of Issue window and other logic 
			as in the complexity effective processors paper; issue_width==dispatch_width -->
			<param name="commit_width" value="0"/>
			<!-- commit_width determines the number of ports of register files -->
			<param name="fp_issue_width" value="0"/>
			<param name="prediction_width" value="0"/> 
			<!-- number of branch instructions can be predicted simultaneously-->
			<!-- Current version of McPAT does not distinguish int and floating point pipelines 
			Theses parameters are reserved for future use.--> 
			<param name="pipelines_per_core" value="0,0"/>
			<!--integer_pipeline and floating_pipelines, if the floating_pipelines is 0, then the pipeline is shared-->
			<param name="pipeline_depth" value="0,0"/>
			<!-- pipeline depth of int and fp, if pipeline is shared, the second number is the average cycles of fp ops -->
			<!-- issue and exe unit-->
			<param name="ALU_per_core" value="1"/>
			<!-- contains an adder, a shifter, and a logical unit -->
			<param name="MUL_per_core" value="0"/>
			<!-- For MUL and Div -->
			<param name="FPU_per_core" value="0"/>		
			<!-- buffer between IF and ID stage -->
			<param name="instruction_buffer_size" value="0"/>
			<!-- buffer between ID and sche/exe stage -->
			<param name="decoded_stream_buffer_size" value="0"/>
			<param name="instruction_window_scheme" value="0"/><!-- 0 PHYREG based, 1 RSBASED-->
			<!-- McPAT support 2 types of OoO cores, RS based and physical reg based-->
			<param name="instruction_window_size" value="0"/>
			<param name="fp_instruction_window_size" value="0"/>
			<!-- Numbers need to be confirmed -->
			<!-- the instruction issue Q as in Alpha 21264; The RS as in Intel P6 -->
			<param name="ROB_size" value="0"/>
			<!-- each in-flight instruction has an entry in ROB -->
			<!-- registers -->
			<param name="archi_Regs_IRF_size" value="0"/>			
			<param name="archi_Regs_FRF_size" value="0"/>
			<!--  if OoO processor, phy_reg number is needed for renaming logic, 
			renaming logic is for both integer and floating point insts.  -->
			<param name="phy_Regs_IRF_size" value="0"/>
			<param name="phy_Regs_FRF_size" value="0"/>
			<!-- rename logic -->
			<param name="rename_scheme" value="0"/>
			<!-- can be RAM based(0) or CAM based(1) rename scheme 
			RAM-based scheme will have free list, status table;
			CAM-based scheme have the valid bit in the data field of the CAM -->
			<param name="checkpoint_depth" value="0"/>
			<!-- RAM and CAM RAT contains checkpoints, checkpoint_depth=# of in_flight speculations;
			RAM-based RAT should not have more than 4 GCs (e.g., MIPS R10000). 
			McPAT assumes the exsistance of RRAT when the RAM-RAT having no GCs (e.g., Netburst)
			CAM-based RAT should have at least 1 GC and can have more than 8 GCs. -->
			<param name="register_windows_size" value="0"/>
			<!-- how many windows in the windowed register file, sun processors;
			no register windowing is used when this number is 0 -->
			<!-- In OoO cores, loads and stores can be issued whether inorder(Pentium Pro) or (OoO)out-of-order(Alpha),
			They will always try to execute out-of-order though. -->
			<param name="LSU_order" value="inorder"/>
			<param name="store_buffer_size" value="0"/>
			<!-- By default, in-order cores do not have load buffers -->
			<param name="load_buffer_size" value="0"/>	
			<!-- number of ports refer to sustain-able concurrent memory accesses --> 
			<param name="memory_ports" value="0"/>	
			<!-- max_allowed_in_flight_memo_instructions determines the # of ports of load and store buffer
			as well as the ports of Dcache which is connected to LSU -->	
			<!-- dual-pumped Dcache can be used to save the extra read/write ports -->
			<param name="RAS_size" value="0"/>						
			<!-- general stats, defines simulation periods;require total, idle, and busy cycles for sanity check  -->
			<!-- please note: if target architecture is X86, then all the instructions refer to (fused) micro-ops -->
			<stat name="total_instructions" value="15376"/>
			<stat name="int_instructions" value="15376"/>
			<stat name="fp_instructions" value="0"/>
			<stat name="branch_instructions" value="0"/>
			<stat name="branch_mispredictions" value="0"/>
			<stat name="load_instructions" value="0"/>
			<stat name="store_instructions" value="0"/>
			<stat name="committed_instructions" value="0"/>
			<stat name="committed_int_instructions" value="0"/>
			<stat name="committed_fp_instructions" value="0"/>
			<stat name="pipeline_duty_cycle" value="1"/><!--<=1, runtime_ipc/peak_ipc; averaged for all cores if homogeneous -->
			<!-- the following cycle stats are used for heterogeneous cores only, 
				please ignore them if homogeneous cores -->
			<stat name="total_cycles" value="2660804"/>
			<stat name="idle_cycles" value="2645428"/>
			<stat name="busy_cycles"  value="15376"/>
			<!-- instruction buffer stats -->
			<!-- ROB stats, both RS and Phy based OoOs have ROB
			performance simulator should capture the difference on accesses,
			otherwise, McPAT has to guess based on number of committed instructions. -->
			<stat name="ROB_reads" value="0"/>
			<stat name="ROB_writes" value="0"/>
			<!-- RAT accesses -->
			<stat name="rename_reads" value="0"/> <!--lookup in renaming logic -->
			<stat name="rename_writes" value="0"/><!--update dest regs. renaming logic -->
			<stat name="fp_rename_reads" value="0"/>
			<stat name="fp_rename_writes" value="0"/>
			<!-- decode and rename stage use this, should be total ic - nop -->
			<!-- Inst window stats -->
			<stat name="inst_window_reads" value="0"/>
			<stat name="inst_window_writes" value="0"/>
			<stat name="inst_window_wakeup_accesses" value="0"/>
			<stat name="fp_inst_window_reads" value="0"/>
			<stat name="fp_inst_window_writes" value="0"/>
			<stat name="fp_inst_window_wakeup_accesses" value="0"/>
			<!--  RF accesses -->
			<stat name="int_regfile_reads" value="0"/>
			<stat name="float_regfile_reads" value="0"/>
			<stat name="int_regfile_writes" value="0"/>
			<stat name="float_regfile_writes" value="0"/>
			<!-- accesses to the working reg -->
			<stat name="function_calls" value="0"/>
			<stat name="context_switches" value="0"/>
			<!-- Number of Windows switches (number of function calls and returns)-->
			<!-- Alu stats by default, the processor has one FPU that includes the divider and 
			 multiplier. The fpu accesses should include accesses to multiplier and divider  -->
			<stat name="ialu_accesses" value="15376"/>			
			<stat name="fpu_accesses" value="0"/>
			<stat name="mul_accesses" value="0"/>
			<stat name="cdb_alu_accesses" value="0"/>
			<stat name="cdb_mul_accesses" value="0"/>
			<stat name="cdb_fpu_accesses" value="0"/>
			<!-- multiple cycle accesses should be counted multiple times, 
			otherwise, McPAT can use internal counter for different floating point instructions 
			to get final accesses. But that needs detailed info for floating point inst mix -->
			<!--  currently the performance simulator should 
			make sure all the numbers are final numbers, 
			including the explicit read/write accesses, 
			and the implicit accesses such as replacements and etc.
			Future versions of McPAT may be able to reason the implicit access
			based on param and stats of last level cache
			The same rule applies to all cache access stats too!  -->
			<!-- following is AF for max power computation. 
				Do not change them, unless you understand them-->
			<stat name="IFU_duty_cycle" value="0.9"/>
			<stat name="BR_duty_cycle" value="0.72"/><!--branch-->			
			<stat name="LSU_duty_cycle" value="0.71"/>
			<stat name="MemManU_I_duty_cycle" value="0.9"/>
			<stat name="MemManU_D_duty_cycle" value="0.71"/>
			<stat name="ALU_duty_cycle" value="0.76"/>
			<!-- (.78*2+.71)/3 -->
			<stat name="MUL_duty_cycle" value="0.82"/>
			<stat name="FPU_duty_cycle" value="0.0"/>
			<stat name="ALU_cdb_duty_cycle" value="0.76"/>
			<stat name="MUL_cdb_duty_cycle" value="0.82"/>
			<stat name="FPU_cdb_duty_cycle" value="0.0"/>
		</component>
		<component id="system.core13" name="core13">
			<!-- Core property -->
			<param name="clock_rate" value="5"/>
			<!-- for cores with unknown timing, set to 0 to force off the opt flag -->
			<param name="opt_local" value="0"/>
			<param name="instruction_length" value="32"/>
			<param name="opcode_width" value="7"/>
			<param name="x86" value="0"/>
			<param name="micro_opcode_width" value="0"/>
			<param name="machine_type" value="1"/>
			<!-- inorder/OoO; 1 inorder; 0 OOO-->
			<param name="number_hardware_threads" value="1"/>
			<!-- number_instruction_fetch_ports(icache ports) is always 1 in single-thread processor,
			it only may be more than one in SMT processors. BTB ports always equals to fetch ports since 
			branch information in consecutive branch instructions in the same fetch group can be read out from BTB once.--> 
			<param name="fetch_width" value="0"/>
			<!-- fetch_width determines the size of cachelines of L1 cache block -->
			<param name="number_instruction_fetch_ports" value="0"/>
			<param name="decode_width" value="0"/>
			<!-- decode_width determines the number of ports of the 
			renaming table (both RAM and CAM) scheme -->
			<param name="issue_width" value="0"/>
			<param name="peak_issue_width" value="0"/>
			<!-- issue_width determines the number of ports of Issue window and other logic 
			as in the complexity effective processors paper; issue_width==dispatch_width -->
			<param name="commit_width" value="0"/>
			<!-- commit_width determines the number of ports of register files -->
			<param name="fp_issue_width" value="0"/>
			<param name="prediction_width" value="0"/> 
			<!-- number of branch instructions can be predicted simultaneously-->
			<!-- Current version of McPAT does not distinguish int and floating point pipelines 
			Theses parameters are reserved for future use.--> 
			<param name="pipelines_per_core" value="0,0"/>
			<!--integer_pipeline and floating_pipelines, if the floating_pipelines is 0, then the pipeline is shared-->
			<param name="pipeline_depth" value="0,0"/>
			<!-- pipeline depth of int and fp, if pipeline is shared, the second number is the average cycles of fp ops -->
			<!-- issue and exe unit-->
			<param name="ALU_per_core" value="1"/>
			<!-- contains an adder, a shifter, and a logical unit -->
			<param name="MUL_per_core" value="0"/>
			<!-- For MUL and Div -->
			<param name="FPU_per_core" value="0"/>		
			<!-- buffer between IF and ID stage -->
			<param name="instruction_buffer_size" value="0"/>
			<!-- buffer between ID and sche/exe stage -->
			<param name="decoded_stream_buffer_size" value="0"/>
			<param name="instruction_window_scheme" value="0"/><!-- 0 PHYREG based, 1 RSBASED-->
			<!-- McPAT support 2 types of OoO cores, RS based and physical reg based-->
			<param name="instruction_window_size" value="0"/>
			<param name="fp_instruction_window_size" value="0"/>
			<!-- Numbers need to be confirmed -->
			<!-- the instruction issue Q as in Alpha 21264; The RS as in Intel P6 -->
			<param name="ROB_size" value="0"/>
			<!-- each in-flight instruction has an entry in ROB -->
			<!-- registers -->
			<param name="archi_Regs_IRF_size" value="0"/>			
			<param name="archi_Regs_FRF_size" value="0"/>
			<!--  if OoO processor, phy_reg number is needed for renaming logic, 
			renaming logic is for both integer and floating point insts.  -->
			<param name="phy_Regs_IRF_size" value="0"/>
			<param name="phy_Regs_FRF_size" value="0"/>
			<!-- rename logic -->
			<param name="rename_scheme" value="0"/>
			<!-- can be RAM based(0) or CAM based(1) rename scheme 
			RAM-based scheme will have free list, status table;
			CAM-based scheme have the valid bit in the data field of the CAM -->
			<param name="checkpoint_depth" value="0"/>
			<!-- RAM and CAM RAT contains checkpoints, checkpoint_depth=# of in_flight speculations;
			RAM-based RAT should not have more than 4 GCs (e.g., MIPS R10000). 
			McPAT assumes the exsistance of RRAT when the RAM-RAT having no GCs (e.g., Netburst)
			CAM-based RAT should have at least 1 GC and can have more than 8 GCs. -->
			<param name="register_windows_size" value="0"/>
			<!-- how many windows in the windowed register file, sun processors;
			no register windowing is used when this number is 0 -->
			<!-- In OoO cores, loads and stores can be issued whether inorder(Pentium Pro) or (OoO)out-of-order(Alpha),
			They will always try to execute out-of-order though. -->
			<param name="LSU_order" value="inorder"/>
			<param name="store_buffer_size" value="0"/>
			<!-- By default, in-order cores do not have load buffers -->
			<param name="load_buffer_size" value="0"/>	
			<!-- number of ports refer to sustain-able concurrent memory accesses --> 
			<param name="memory_ports" value="0"/>	
			<!-- max_allowed_in_flight_memo_instructions determines the # of ports of load and store buffer
			as well as the ports of Dcache which is connected to LSU -->	
			<!-- dual-pumped Dcache can be used to save the extra read/write ports -->
			<param name="RAS_size" value="0"/>						
			<!-- general stats, defines simulation periods;require total, idle, and busy cycles for sanity check  -->
			<!-- please note: if target architecture is X86, then all the instructions refer to (fused) micro-ops -->
			<stat name="total_instructions" value="0"/>
			<stat name="int_instructions" value="0"/>
			<stat name="fp_instructions" value="0"/>
			<stat name="branch_instructions" value="0"/>
			<stat name="branch_mispredictions" value="0"/>
			<stat name="load_instructions" value="0"/>
			<stat name="store_instructions" value="0"/>
			<stat name="committed_instructions" value="0"/>
			<stat name="committed_int_instructions" value="0"/>
			<stat name="committed_fp_instructions" value="0"/>
			<stat name="pipeline_duty_cycle" value="1"/><!--<=1, runtime_ipc/peak_ipc; averaged for all cores if homogeneous -->
			<!-- the following cycle stats are used for heterogeneous cores only, 
				please ignore them if homogeneous cores -->
			<stat name="total_cycles" value="2660804"/>
			<stat name="idle_cycles" value="2660804"/>
			<stat name="busy_cycles"  value="0"/>
			<!-- instruction buffer stats -->
			<!-- ROB stats, both RS and Phy based OoOs have ROB
			performance simulator should capture the difference on accesses,
			otherwise, McPAT has to guess based on number of committed instructions. -->
			<stat name="ROB_reads" value="0"/>
			<stat name="ROB_writes" value="0"/>
			<!-- RAT accesses -->
			<stat name="rename_reads" value="0"/> <!--lookup in renaming logic -->
			<stat name="rename_writes" value="0"/><!--update dest regs. renaming logic -->
			<stat name="fp_rename_reads" value="0"/>
			<stat name="fp_rename_writes" value="0"/>
			<!-- decode and rename stage use this, should be total ic - nop -->
			<!-- Inst window stats -->
			<stat name="inst_window_reads" value="0"/>
			<stat name="inst_window_writes" value="0"/>
			<stat name="inst_window_wakeup_accesses" value="0"/>
			<stat name="fp_inst_window_reads" value="0"/>
			<stat name="fp_inst_window_writes" value="0"/>
			<stat name="fp_inst_window_wakeup_accesses" value="0"/>
			<!--  RF accesses -->
			<stat name="int_regfile_reads" value="0"/>
			<stat name="float_regfile_reads" value="0"/>
			<stat name="int_regfile_writes" value="0"/>
			<stat name="float_regfile_writes" value="0"/>
			<!-- accesses to the working reg -->
			<stat name="function_calls" value="0"/>
			<stat name="context_switches" value="0"/>
			<!-- Number of Windows switches (number of function calls and returns)-->
			<!-- Alu stats by default, the processor has one FPU that includes the divider and 
			 multiplier. The fpu accesses should include accesses to multiplier and divider  -->
			<stat name="ialu_accesses" value="0"/>			
			<stat name="fpu_accesses" value="0"/>
			<stat name="mul_accesses" value="0"/>
			<stat name="cdb_alu_accesses" value="0"/>
			<stat name="cdb_mul_accesses" value="0"/>
			<stat name="cdb_fpu_accesses" value="0"/>
			<!-- multiple cycle accesses should be counted multiple times, 
			otherwise, McPAT can use internal counter for different floating point instructions 
			to get final accesses. But that needs detailed info for floating point inst mix -->
			<!--  currently the performance simulator should 
			make sure all the numbers are final numbers, 
			including the explicit read/write accesses, 
			and the implicit accesses such as replacements and etc.
			Future versions of McPAT may be able to reason the implicit access
			based on param and stats of last level cache
			The same rule applies to all cache access stats too!  -->
			<!-- following is AF for max power computation. 
				Do not change them, unless you understand them-->
			<stat name="IFU_duty_cycle" value="0.9"/>
			<stat name="BR_duty_cycle" value="0.72"/><!--branch-->			
			<stat name="LSU_duty_cycle" value="0.71"/>
			<stat name="MemManU_I_duty_cycle" value="0.9"/>
			<stat name="MemManU_D_duty_cycle" value="0.71"/>
			<stat name="ALU_duty_cycle" value="0.76"/>
			<!-- (.78*2+.71)/3 -->
			<stat name="MUL_duty_cycle" value="0.82"/>
			<stat name="FPU_duty_cycle" value="0.0"/>
			<stat name="ALU_cdb_duty_cycle" value="0.76"/>
			<stat name="MUL_cdb_duty_cycle" value="0.82"/>
			<stat name="FPU_cdb_duty_cycle" value="0.0"/>
		</component>
		<component id="system.core14" name="core14">
			<!-- Core property -->
			<param name="clock_rate" value="5"/>
			<!-- for cores with unknown timing, set to 0 to force off the opt flag -->
			<param name="opt_local" value="0"/>
			<param name="instruction_length" value="32"/>
			<param name="opcode_width" value="7"/>
			<param name="x86" value="0"/>
			<param name="micro_opcode_width" value="0"/>
			<param name="machine_type" value="1"/>
			<!-- inorder/OoO; 1 inorder; 0 OOO-->
			<param name="number_hardware_threads" value="1"/>
			<!-- number_instruction_fetch_ports(icache ports) is always 1 in single-thread processor,
			it only may be more than one in SMT processors. BTB ports always equals to fetch ports since 
			branch information in consecutive branch instructions in the same fetch group can be read out from BTB once.--> 
			<param name="fetch_width" value="0"/>
			<!-- fetch_width determines the size of cachelines of L1 cache block -->
			<param name="number_instruction_fetch_ports" value="0"/>
			<param name="decode_width" value="0"/>
			<!-- decode_width determines the number of ports of the 
			renaming table (both RAM and CAM) scheme -->
			<param name="issue_width" value="0"/>
			<param name="peak_issue_width" value="0"/>
			<!-- issue_width determines the number of ports of Issue window and other logic 
			as in the complexity effective processors paper; issue_width==dispatch_width -->
			<param name="commit_width" value="0"/>
			<!-- commit_width determines the number of ports of register files -->
			<param name="fp_issue_width" value="0"/>
			<param name="prediction_width" value="0"/> 
			<!-- number of branch instructions can be predicted simultaneously-->
			<!-- Current version of McPAT does not distinguish int and floating point pipelines 
			Theses parameters are reserved for future use.--> 
			<param name="pipelines_per_core" value="0,0"/>
			<!--integer_pipeline and floating_pipelines, if the floating_pipelines is 0, then the pipeline is shared-->
			<param name="pipeline_depth" value="0,0"/>
			<!-- pipeline depth of int and fp, if pipeline is shared, the second number is the average cycles of fp ops -->
			<!-- issue and exe unit-->
			<param name="ALU_per_core" value="1"/>
			<!-- contains an adder, a shifter, and a logical unit -->
			<param name="MUL_per_core" value="0"/>
			<!-- For MUL and Div -->
			<param name="FPU_per_core" value="0"/>		
			<!-- buffer between IF and ID stage -->
			<param name="instruction_buffer_size" value="0"/>
			<!-- buffer between ID and sche/exe stage -->
			<param name="decoded_stream_buffer_size" value="0"/>
			<param name="instruction_window_scheme" value="0"/><!-- 0 PHYREG based, 1 RSBASED-->
			<!-- McPAT support 2 types of OoO cores, RS based and physical reg based-->
			<param name="instruction_window_size" value="0"/>
			<param name="fp_instruction_window_size" value="0"/>
			<!-- Numbers need to be confirmed -->
			<!-- the instruction issue Q as in Alpha 21264; The RS as in Intel P6 -->
			<param name="ROB_size" value="0"/>
			<!-- each in-flight instruction has an entry in ROB -->
			<!-- registers -->
			<param name="archi_Regs_IRF_size" value="0"/>			
			<param name="archi_Regs_FRF_size" value="0"/>
			<!--  if OoO processor, phy_reg number is needed for renaming logic, 
			renaming logic is for both integer and floating point insts.  -->
			<param name="phy_Regs_IRF_size" value="0"/>
			<param name="phy_Regs_FRF_size" value="0"/>
			<!-- rename logic -->
			<param name="rename_scheme" value="0"/>
			<!-- can be RAM based(0) or CAM based(1) rename scheme 
			RAM-based scheme will have free list, status table;
			CAM-based scheme have the valid bit in the data field of the CAM -->
			<param name="checkpoint_depth" value="0"/>
			<!-- RAM and CAM RAT contains checkpoints, checkpoint_depth=# of in_flight speculations;
			RAM-based RAT should not have more than 4 GCs (e.g., MIPS R10000). 
			McPAT assumes the exsistance of RRAT when the RAM-RAT having no GCs (e.g., Netburst)
			CAM-based RAT should have at least 1 GC and can have more than 8 GCs. -->
			<param name="register_windows_size" value="0"/>
			<!-- how many windows in the windowed register file, sun processors;
			no register windowing is used when this number is 0 -->
			<!-- In OoO cores, loads and stores can be issued whether inorder(Pentium Pro) or (OoO)out-of-order(Alpha),
			They will always try to execute out-of-order though. -->
			<param name="LSU_order" value="inorder"/>
			<param name="store_buffer_size" value="0"/>
			<!-- By default, in-order cores do not have load buffers -->
			<param name="load_buffer_size" value="0"/>	
			<!-- number of ports refer to sustain-able concurrent memory accesses --> 
			<param name="memory_ports" value="0"/>	
			<!-- max_allowed_in_flight_memo_instructions determines the # of ports of load and store buffer
			as well as the ports of Dcache which is connected to LSU -->	
			<!-- dual-pumped Dcache can be used to save the extra read/write ports -->
			<param name="RAS_size" value="0"/>						
			<!-- general stats, defines simulation periods;require total, idle, and busy cycles for sanity check  -->
			<!-- please note: if target architecture is X86, then all the instructions refer to (fused) micro-ops -->
			<stat name="total_instructions" value="0"/>
			<stat name="int_instructions" value="0"/>
			<stat name="fp_instructions" value="0"/>
			<stat name="branch_instructions" value="0"/>
			<stat name="branch_mispredictions" value="0"/>
			<stat name="load_instructions" value="0"/>
			<stat name="store_instructions" value="0"/>
			<stat name="committed_instructions" value="0"/>
			<stat name="committed_int_instructions" value="0"/>
			<stat name="committed_fp_instructions" value="0"/>
			<stat name="pipeline_duty_cycle" value="1"/><!--<=1, runtime_ipc/peak_ipc; averaged for all cores if homogeneous -->
			<!-- the following cycle stats are used for heterogeneous cores only, 
				please ignore them if homogeneous cores -->
			<stat name="total_cycles" value="2660804"/>
			<stat name="idle_cycles" value="2660804"/>
			<stat name="busy_cycles"  value="0"/>
			<!-- instruction buffer stats -->
			<!-- ROB stats, both RS and Phy based OoOs have ROB
			performance simulator should capture the difference on accesses,
			otherwise, McPAT has to guess based on number of committed instructions. -->
			<stat name="ROB_reads" value="0"/>
			<stat name="ROB_writes" value="0"/>
			<!-- RAT accesses -->
			<stat name="rename_reads" value="0"/> <!--lookup in renaming logic -->
			<stat name="rename_writes" value="0"/><!--update dest regs. renaming logic -->
			<stat name="fp_rename_reads" value="0"/>
			<stat name="fp_rename_writes" value="0"/>
			<!-- decode and rename stage use this, should be total ic - nop -->
			<!-- Inst window stats -->
			<stat name="inst_window_reads" value="0"/>
			<stat name="inst_window_writes" value="0"/>
			<stat name="inst_window_wakeup_accesses" value="0"/>
			<stat name="fp_inst_window_reads" value="0"/>
			<stat name="fp_inst_window_writes" value="0"/>
			<stat name="fp_inst_window_wakeup_accesses" value="0"/>
			<!--  RF accesses -->
			<stat name="int_regfile_reads" value="0"/>
			<stat name="float_regfile_reads" value="0"/>
			<stat name="int_regfile_writes" value="0"/>
			<stat name="float_regfile_writes" value="0"/>
			<!-- accesses to the working reg -->
			<stat name="function_calls" value="0"/>
			<stat name="context_switches" value="0"/>
			<!-- Number of Windows switches (number of function calls and returns)-->
			<!-- Alu stats by default, the processor has one FPU that includes the divider and 
			 multiplier. The fpu accesses should include accesses to multiplier and divider  -->
			<stat name="ialu_accesses" value="0"/>			
			<stat name="fpu_accesses" value="0"/>
			<stat name="mul_accesses" value="0"/>
			<stat name="cdb_alu_accesses" value="0"/>
			<stat name="cdb_mul_accesses" value="0"/>
			<stat name="cdb_fpu_accesses" value="0"/>
			<!-- multiple cycle accesses should be counted multiple times, 
			otherwise, McPAT can use internal counter for different floating point instructions 
			to get final accesses. But that needs detailed info for floating point inst mix -->
			<!--  currently the performance simulator should 
			make sure all the numbers are final numbers, 
			including the explicit read/write accesses, 
			and the implicit accesses such as replacements and etc.
			Future versions of McPAT may be able to reason the implicit access
			based on param and stats of last level cache
			The same rule applies to all cache access stats too!  -->
			<!-- following is AF for max power computation. 
				Do not change them, unless you understand them-->
			<stat name="IFU_duty_cycle" value="0.9"/>
			<stat name="BR_duty_cycle" value="0.72"/><!--branch-->			
			<stat name="LSU_duty_cycle" value="0.71"/>
			<stat name="MemManU_I_duty_cycle" value="0.9"/>
			<stat name="MemManU_D_duty_cycle" value="0.71"/>
			<stat name="ALU_duty_cycle" value="0.76"/>
			<!-- (.78*2+.71)/3 -->
			<stat name="MUL_duty_cycle" value="0.82"/>
			<stat name="FPU_duty_cycle" value="0.0"/>
			<stat name="ALU_cdb_duty_cycle" value="0.76"/>
			<stat name="MUL_cdb_duty_cycle" value="0.82"/>
			<stat name="FPU_cdb_duty_cycle" value="0.0"/>
		</component>
		<component id="system.core15" name="core15">
			<!-- Core property -->
			<param name="clock_rate" value="5"/>
			<!-- for cores with unknown timing, set to 0 to force off the opt flag -->
			<param name="opt_local" value="0"/>
			<param name="instruction_length" value="32"/>
			<param name="opcode_width" value="7"/>
			<param name="x86" value="0"/>
			<param name="micro_opcode_width" value="0"/>
			<param name="machine_type" value="1"/>
			<!-- inorder/OoO; 1 inorder; 0 OOO-->
			<param name="number_hardware_threads" value="1"/>
			<!-- number_instruction_fetch_ports(icache ports) is always 1 in single-thread processor,
			it only may be more than one in SMT processors. BTB ports always equals to fetch ports since 
			branch information in consecutive branch instructions in the same fetch group can be read out from BTB once.--> 
			<param name="fetch_width" value="0"/>
			<!-- fetch_width determines the size of cachelines of L1 cache block -->
			<param name="number_instruction_fetch_ports" value="0"/>
			<param name="decode_width" value="0"/>
			<!-- decode_width determines the number of ports of the 
			renaming table (both RAM and CAM) scheme -->
			<param name="issue_width" value="0"/>
			<param name="peak_issue_width" value="0"/>
			<!-- issue_width determines the number of ports of Issue window and other logic 
			as in the complexity effective processors paper; issue_width==dispatch_width -->
			<param name="commit_width" value="0"/>
			<!-- commit_width determines the number of ports of register files -->
			<param name="fp_issue_width" value="0"/>
			<param name="prediction_width" value="0"/> 
			<!-- number of branch instructions can be predicted simultaneously-->
			<!-- Current version of McPAT does not distinguish int and floating point pipelines 
			Theses parameters are reserved for future use.--> 
			<param name="pipelines_per_core" value="0,0"/>
			<!--integer_pipeline and floating_pipelines, if the floating_pipelines is 0, then the pipeline is shared-->
			<param name="pipeline_depth" value="0,0"/>
			<!-- pipeline depth of int and fp, if pipeline is shared, the second number is the average cycles of fp ops -->
			<!-- issue and exe unit-->
			<param name="ALU_per_core" value="1"/>
			<!-- contains an adder, a shifter, and a logical unit -->
			<param name="MUL_per_core" value="0"/>
			<!-- For MUL and Div -->
			<param name="FPU_per_core" value="0"/>		
			<!-- buffer between IF and ID stage -->
			<param name="instruction_buffer_size" value="0"/>
			<!-- buffer between ID and sche/exe stage -->
			<param name="decoded_stream_buffer_size" value="0"/>
			<param name="instruction_window_scheme" value="0"/><!-- 0 PHYREG based, 1 RSBASED-->
			<!-- McPAT support 2 types of OoO cores, RS based and physical reg based-->
			<param name="instruction_window_size" value="0"/>
			<param name="fp_instruction_window_size" value="0"/>
			<!-- Numbers need to be confirmed -->
			<!-- the instruction issue Q as in Alpha 21264; The RS as in Intel P6 -->
			<param name="ROB_size" value="0"/>
			<!-- each in-flight instruction has an entry in ROB -->
			<!-- registers -->
			<param name="archi_Regs_IRF_size" value="0"/>			
			<param name="archi_Regs_FRF_size" value="0"/>
			<!--  if OoO processor, phy_reg number is needed for renaming logic, 
			renaming logic is for both integer and floating point insts.  -->
			<param name="phy_Regs_IRF_size" value="0"/>
			<param name="phy_Regs_FRF_size" value="0"/>
			<!-- rename logic -->
			<param name="rename_scheme" value="0"/>
			<!-- can be RAM based(0) or CAM based(1) rename scheme 
			RAM-based scheme will have free list, status table;
			CAM-based scheme have the valid bit in the data field of the CAM -->
			<param name="checkpoint_depth" value="0"/>
			<!-- RAM and CAM RAT contains checkpoints, checkpoint_depth=# of in_flight speculations;
			RAM-based RAT should not have more than 4 GCs (e.g., MIPS R10000). 
			McPAT assumes the exsistance of RRAT when the RAM-RAT having no GCs (e.g., Netburst)
			CAM-based RAT should have at least 1 GC and can have more than 8 GCs. -->
			<param name="register_windows_size" value="0"/>
			<!-- how many windows in the windowed register file, sun processors;
			no register windowing is used when this number is 0 -->
			<!-- In OoO cores, loads and stores can be issued whether inorder(Pentium Pro) or (OoO)out-of-order(Alpha),
			They will always try to execute out-of-order though. -->
			<param name="LSU_order" value="inorder"/>
			<param name="store_buffer_size" value="0"/>
			<!-- By default, in-order cores do not have load buffers -->
			<param name="load_buffer_size" value="0"/>	
			<!-- number of ports refer to sustain-able concurrent memory accesses --> 
			<param name="memory_ports" value="0"/>	
			<!-- max_allowed_in_flight_memo_instructions determines the # of ports of load and store buffer
			as well as the ports of Dcache which is connected to LSU -->	
			<!-- dual-pumped Dcache can be used to save the extra read/write ports -->
			<param name="RAS_size" value="0"/>						
			<!-- general stats, defines simulation periods;require total, idle, and busy cycles for sanity check  -->
			<!-- please note: if target architecture is X86, then all the instructions refer to (fused) micro-ops -->
			<stat name="total_instructions" value="46128"/>
			<stat name="int_instructions" value="46128"/>
			<stat name="fp_instructions" value="0"/>
			<stat name="branch_instructions" value="0"/>
			<stat name="branch_mispredictions" value="0"/>
			<stat name="load_instructions" value="0"/>
			<stat name="store_instructions" value="0"/>
			<stat name="committed_instructions" value="0"/>
			<stat name="committed_int_instructions" value="0"/>
			<stat name="committed_fp_instructions" value="0"/>
			<stat name="pipeline_duty_cycle" value="1"/><!--<=1, runtime_ipc/peak_ipc; averaged for all cores if homogeneous -->
			<!-- the following cycle stats are used for heterogeneous cores only, 
				please ignore them if homogeneous cores -->
			<stat name="total_cycles" value="2660804"/>
			<stat name="idle_cycles" value="2614676"/>
			<stat name="busy_cycles"  value="46128"/>
			<!-- instruction buffer stats -->
			<!-- ROB stats, both RS and Phy based OoOs have ROB
			performance simulator should capture the difference on accesses,
			otherwise, McPAT has to guess based on number of committed instructions. -->
			<stat name="ROB_reads" value="0"/>
			<stat name="ROB_writes" value="0"/>
			<!-- RAT accesses -->
			<stat name="rename_reads" value="0"/> <!--lookup in renaming logic -->
			<stat name="rename_writes" value="0"/><!--update dest regs. renaming logic -->
			<stat name="fp_rename_reads" value="0"/>
			<stat name="fp_rename_writes" value="0"/>
			<!-- decode and rename stage use this, should be total ic - nop -->
			<!-- Inst window stats -->
			<stat name="inst_window_reads" value="0"/>
			<stat name="inst_window_writes" value="0"/>
			<stat name="inst_window_wakeup_accesses" value="0"/>
			<stat name="fp_inst_window_reads" value="0"/>
			<stat name="fp_inst_window_writes" value="0"/>
			<stat name="fp_inst_window_wakeup_accesses" value="0"/>
			<!--  RF accesses -->
			<stat name="int_regfile_reads" value="0"/>
			<stat name="float_regfile_reads" value="0"/>
			<stat name="int_regfile_writes" value="0"/>
			<stat name="float_regfile_writes" value="0"/>
			<!-- accesses to the working reg -->
			<stat name="function_calls" value="0"/>
			<stat name="context_switches" value="0"/>
			<!-- Number of Windows switches (number of function calls and returns)-->
			<!-- Alu stats by default, the processor has one FPU that includes the divider and 
			 multiplier. The fpu accesses should include accesses to multiplier and divider  -->
			<stat name="ialu_accesses" value="46128"/>			
			<stat name="fpu_accesses" value="0"/>
			<stat name="mul_accesses" value="0"/>
			<stat name="cdb_alu_accesses" value="0"/>
			<stat name="cdb_mul_accesses" value="0"/>
			<stat name="cdb_fpu_accesses" value="0"/>
			<!-- multiple cycle accesses should be counted multiple times, 
			otherwise, McPAT can use internal counter for different floating point instructions 
			to get final accesses. But that needs detailed info for floating point inst mix -->
			<!--  currently the performance simulator should 
			make sure all the numbers are final numbers, 
			including the explicit read/write accesses, 
			and the implicit accesses such as replacements and etc.
			Future versions of McPAT may be able to reason the implicit access
			based on param and stats of last level cache
			The same rule applies to all cache access stats too!  -->
			<!-- following is AF for max power computation. 
				Do not change them, unless you understand them-->
			<stat name="IFU_duty_cycle" value="0.9"/>
			<stat name="BR_duty_cycle" value="0.72"/><!--branch-->			
			<stat name="LSU_duty_cycle" value="0.71"/>
			<stat name="MemManU_I_duty_cycle" value="0.9"/>
			<stat name="MemManU_D_duty_cycle" value="0.71"/>
			<stat name="ALU_duty_cycle" value="0.76"/>
			<!-- (.78*2+.71)/3 -->
			<stat name="MUL_duty_cycle" value="0.82"/>
			<stat name="FPU_duty_cycle" value="0.0"/>
			<stat name="ALU_cdb_duty_cycle" value="0.76"/>
			<stat name="MUL_cdb_duty_cycle" value="0.82"/>
			<stat name="FPU_cdb_duty_cycle" value="0.0"/>
		</component>
		<component id="system.core16" name="core16">
			<!-- Core property -->
			<param name="clock_rate" value="5"/>
			<!-- for cores with unknown timing, set to 0 to force off the opt flag -->
			<param name="opt_local" value="0"/>
			<param name="instruction_length" value="32"/>
			<param name="opcode_width" value="7"/>
			<param name="x86" value="0"/>
			<param name="micro_opcode_width" value="0"/>
			<param name="machine_type" value="1"/>
			<!-- inorder/OoO; 1 inorder; 0 OOO-->
			<param name="number_hardware_threads" value="1"/>
			<!-- number_instruction_fetch_ports(icache ports) is always 1 in single-thread processor,
			it only may be more than one in SMT processors. BTB ports always equals to fetch ports since 
			branch information in consecutive branch instructions in the same fetch group can be read out from BTB once.--> 
			<param name="fetch_width" value="0"/>
			<!-- fetch_width determines the size of cachelines of L1 cache block -->
			<param name="number_instruction_fetch_ports" value="0"/>
			<param name="decode_width" value="0"/>
			<!-- decode_width determines the number of ports of the 
			renaming table (both RAM and CAM) scheme -->
			<param name="issue_width" value="0"/>
			<param name="peak_issue_width" value="0"/>
			<!-- issue_width determines the number of ports of Issue window and other logic 
			as in the complexity effective processors paper; issue_width==dispatch_width -->
			<param name="commit_width" value="0"/>
			<!-- commit_width determines the number of ports of register files -->
			<param name="fp_issue_width" value="0"/>
			<param name="prediction_width" value="0"/> 
			<!-- number of branch instructions can be predicted simultaneously-->
			<!-- Current version of McPAT does not distinguish int and floating point pipelines 
			Theses parameters are reserved for future use.--> 
			<param name="pipelines_per_core" value="0,0"/>
			<!--integer_pipeline and floating_pipelines, if the floating_pipelines is 0, then the pipeline is shared-->
			<param name="pipeline_depth" value="0,0"/>
			<!-- pipeline depth of int and fp, if pipeline is shared, the second number is the average cycles of fp ops -->
			<!-- issue and exe unit-->
			<param name="ALU_per_core" value="1"/>
			<!-- contains an adder, a shifter, and a logical unit -->
			<param name="MUL_per_core" value="0"/>
			<!-- For MUL and Div -->
			<param name="FPU_per_core" value="0"/>		
			<!-- buffer between IF and ID stage -->
			<param name="instruction_buffer_size" value="0"/>
			<!-- buffer between ID and sche/exe stage -->
			<param name="decoded_stream_buffer_size" value="0"/>
			<param name="instruction_window_scheme" value="0"/><!-- 0 PHYREG based, 1 RSBASED-->
			<!-- McPAT support 2 types of OoO cores, RS based and physical reg based-->
			<param name="instruction_window_size" value="0"/>
			<param name="fp_instruction_window_size" value="0"/>
			<!-- Numbers need to be confirmed -->
			<!-- the instruction issue Q as in Alpha 21264; The RS as in Intel P6 -->
			<param name="ROB_size" value="0"/>
			<!-- each in-flight instruction has an entry in ROB -->
			<!-- registers -->
			<param name="archi_Regs_IRF_size" value="0"/>			
			<param name="archi_Regs_FRF_size" value="0"/>
			<!--  if OoO processor, phy_reg number is needed for renaming logic, 
			renaming logic is for both integer and floating point insts.  -->
			<param name="phy_Regs_IRF_size" value="0"/>
			<param name="phy_Regs_FRF_size" value="0"/>
			<!-- rename logic -->
			<param name="rename_scheme" value="0"/>
			<!-- can be RAM based(0) or CAM based(1) rename scheme 
			RAM-based scheme will have free list, status table;
			CAM-based scheme have the valid bit in the data field of the CAM -->
			<param name="checkpoint_depth" value="0"/>
			<!-- RAM and CAM RAT contains checkpoints, checkpoint_depth=# of in_flight speculations;
			RAM-based RAT should not have more than 4 GCs (e.g., MIPS R10000). 
			McPAT assumes the exsistance of RRAT when the RAM-RAT having no GCs (e.g., Netburst)
			CAM-based RAT should have at least 1 GC and can have more than 8 GCs. -->
			<param name="register_windows_size" value="0"/>
			<!-- how many windows in the windowed register file, sun processors;
			no register windowing is used when this number is 0 -->
			<!-- In OoO cores, loads and stores can be issued whether inorder(Pentium Pro) or (OoO)out-of-order(Alpha),
			They will always try to execute out-of-order though. -->
			<param name="LSU_order" value="inorder"/>
			<param name="store_buffer_size" value="0"/>
			<!-- By default, in-order cores do not have load buffers -->
			<param name="load_buffer_size" value="0"/>	
			<!-- number of ports refer to sustain-able concurrent memory accesses --> 
			<param name="memory_ports" value="0"/>	
			<!-- max_allowed_in_flight_memo_instructions determines the # of ports of load and store buffer
			as well as the ports of Dcache which is connected to LSU -->	
			<!-- dual-pumped Dcache can be used to save the extra read/write ports -->
			<param name="RAS_size" value="0"/>						
			<!-- general stats, defines simulation periods;require total, idle, and busy cycles for sanity check  -->
			<!-- please note: if target architecture is X86, then all the instructions refer to (fused) micro-ops -->
			<stat name="total_instructions" value="0"/>
			<stat name="int_instructions" value="0"/>
			<stat name="fp_instructions" value="0"/>
			<stat name="branch_instructions" value="0"/>
			<stat name="branch_mispredictions" value="0"/>
			<stat name="load_instructions" value="0"/>
			<stat name="store_instructions" value="0"/>
			<stat name="committed_instructions" value="0"/>
			<stat name="committed_int_instructions" value="0"/>
			<stat name="committed_fp_instructions" value="0"/>
			<stat name="pipeline_duty_cycle" value="1"/><!--<=1, runtime_ipc/peak_ipc; averaged for all cores if homogeneous -->
			<!-- the following cycle stats are used for heterogeneous cores only, 
				please ignore them if homogeneous cores -->
			<stat name="total_cycles" value="2660804"/>
			<stat name="idle_cycles" value="2660804"/>
			<stat name="busy_cycles"  value="0"/>
			<!-- instruction buffer stats -->
			<!-- ROB stats, both RS and Phy based OoOs have ROB
			performance simulator should capture the difference on accesses,
			otherwise, McPAT has to guess based on number of committed instructions. -->
			<stat name="ROB_reads" value="0"/>
			<stat name="ROB_writes" value="0"/>
			<!-- RAT accesses -->
			<stat name="rename_reads" value="0"/> <!--lookup in renaming logic -->
			<stat name="rename_writes" value="0"/><!--update dest regs. renaming logic -->
			<stat name="fp_rename_reads" value="0"/>
			<stat name="fp_rename_writes" value="0"/>
			<!-- decode and rename stage use this, should be total ic - nop -->
			<!-- Inst window stats -->
			<stat name="inst_window_reads" value="0"/>
			<stat name="inst_window_writes" value="0"/>
			<stat name="inst_window_wakeup_accesses" value="0"/>
			<stat name="fp_inst_window_reads" value="0"/>
			<stat name="fp_inst_window_writes" value="0"/>
			<stat name="fp_inst_window_wakeup_accesses" value="0"/>
			<!--  RF accesses -->
			<stat name="int_regfile_reads" value="0"/>
			<stat name="float_regfile_reads" value="0"/>
			<stat name="int_regfile_writes" value="0"/>
			<stat name="float_regfile_writes" value="0"/>
			<!-- accesses to the working reg -->
			<stat name="function_calls" value="0"/>
			<stat name="context_switches" value="0"/>
			<!-- Number of Windows switches (number of function calls and returns)-->
			<!-- Alu stats by default, the processor has one FPU that includes the divider and 
			 multiplier. The fpu accesses should include accesses to multiplier and divider  -->
			<stat name="ialu_accesses" value="0"/>			
			<stat name="fpu_accesses" value="0"/>
			<stat name="mul_accesses" value="0"/>
			<stat name="cdb_alu_accesses" value="0"/>
			<stat name="cdb_mul_accesses" value="0"/>
			<stat name="cdb_fpu_accesses" value="0"/>
			<!-- multiple cycle accesses should be counted multiple times, 
			otherwise, McPAT can use internal counter for different floating point instructions 
			to get final accesses. But that needs detailed info for floating point inst mix -->
			<!--  currently the performance simulator should 
			make sure all the numbers are final numbers, 
			including the explicit read/write accesses, 
			and the implicit accesses such as replacements and etc.
			Future versions of McPAT may be able to reason the implicit access
			based on param and stats of last level cache
			The same rule applies to all cache access stats too!  -->
			<!-- following is AF for max power computation. 
				Do not change them, unless you understand them-->
			<stat name="IFU_duty_cycle" value="0.9"/>
			<stat name="BR_duty_cycle" value="0.72"/><!--branch-->			
			<stat name="LSU_duty_cycle" value="0.71"/>
			<stat name="MemManU_I_duty_cycle" value="0.9"/>
			<stat name="MemManU_D_duty_cycle" value="0.71"/>
			<stat name="ALU_duty_cycle" value="0.76"/>
			<!-- (.78*2+.71)/3 -->
			<stat name="MUL_duty_cycle" value="0.82"/>
			<stat name="FPU_duty_cycle" value="0.0"/>
			<stat name="ALU_cdb_duty_cycle" value="0.76"/>
			<stat name="MUL_cdb_duty_cycle" value="0.82"/>
			<stat name="FPU_cdb_duty_cycle" value="0.0"/>
		</component>
<!--***************************** CCU ***************************-->
		<component id="system.core17" name="core17">
			<!-- Core property -->
			<param name="clock_rate" value="5"/>
			<!-- for cores with unknown timing, set to 0 to force off the opt flag -->
			<param name="opt_local" value="0"/>
			<param name="instruction_length" value="32"/>
			<param name="opcode_width" value="7"/>
			<param name="x86" value="0"/>
			<param name="micro_opcode_width" value="0"/>
			<param name="machine_type" value="1"/>
			<!-- inorder/OoO; 1 inorder; 0 OOO-->
			<param name="number_hardware_threads" value="1"/>
			<!-- number_instruction_fetch_ports(icache ports) is always 1 in single-thread processor,
			it only may be more than one in SMT processors. BTB ports always equals to fetch ports since 
			branch information in consecutive branch instructions in the same fetch group can be read out from BTB once.--> 
			<param name="fetch_width" value="0"/>
			<!-- fetch_width determines the size of cachelines of L1 cache block -->
			<param name="number_instruction_fetch_ports" value="0"/>
			<param name="decode_width" value="0"/>
			<!-- decode_width determines the number of ports of the 
			renaming table (both RAM and CAM) scheme -->
			<param name="issue_width" value="0"/>
			<param name="peak_issue_width" value="0"/>
			<!-- issue_width determines the number of ports of Issue window and other logic 
			as in the complexity effective processors paper; issue_width==dispatch_width -->
			<param name="commit_width" value="0"/>
			<!-- commit_width determines the number of ports of register files -->
			<param name="fp_issue_width" value="0"/>
			<param name="prediction_width" value="0"/> 
			<!-- number of branch instructions can be predicted simultaneously-->
			<!-- Current version of McPAT does not distinguish int and floating point pipelines 
			Theses parameters are reserved for future use.--> 
			<param name="pipelines_per_core" value="0,0"/>
			<!--integer_pipeline and floating_pipelines, if the floating_pipelines is 0, then the pipeline is shared-->
			<param name="pipeline_depth" value="0,0"/>
			<!-- pipeline depth of int and fp, if pipeline is shared, the second number is the average cycles of fp ops -->
			<!-- issue and exe unit-->
			<param name="ALU_per_core" value="1"/>
			<!-- contains an adder, a shifter, and a logical unit -->
			<param name="MUL_per_core" value="0"/>
			<!-- For MUL and Div -->
			<param name="FPU_per_core" value="0"/>		
			<!-- buffer between IF and ID stage -->
			<param name="instruction_buffer_size" value="1"/>
			<!-- buffer between ID and sche/exe stage -->
			<param name="decoded_stream_buffer_size" value="1"/>
			<param name="instruction_window_scheme" value="0"/><!-- 0 PHYREG based, 1 RSBASED-->
			<!-- McPAT support 2 types of OoO cores, RS based and physical reg based-->
			<param name="instruction_window_size" value="0"/>
			<param name="fp_instruction_window_size" value="0"/>
			<!-- Numbers need to be confirmed -->
			<!-- the instruction issue Q as in Alpha 21264; The RS as in Intel P6 -->
			<param name="ROB_size" value="0"/>
			<!-- each in-flight instruction has an entry in ROB -->
			<!-- registers -->
			<param name="archi_Regs_IRF_size" value="0"/>			
			<param name="archi_Regs_FRF_size" value="0"/>
			<!--  if OoO processor, phy_reg number is needed for renaming logic, 
			renaming logic is for both integer and floating point insts.  -->
			<param name="phy_Regs_IRF_size" value="0"/>
			<param name="phy_Regs_FRF_size" value="0"/>
			<!-- rename logic -->
			<param name="rename_scheme" value="0"/>
			<!-- can be RAM based(0) or CAM based(1) rename scheme 
			RAM-based scheme will have free list, status table;
			CAM-based scheme have the valid bit in the data field of the CAM -->
			<param name="checkpoint_depth" value="0"/>
			<!-- RAM and CAM RAT contains checkpoints, checkpoint_depth=# of in_flight speculations;
			RAM-based RAT should not have more than 4 GCs (e.g., MIPS R10000). 
			McPAT assumes the exsistance of RRAT when the RAM-RAT having no GCs (e.g., Netburst)
			CAM-based RAT should have at least 1 GC and can have more than 8 GCs. -->
			<param name="register_windows_size" value="0"/>
			<!-- how many windows in the windowed register file, sun processors;
			no register windowing is used when this number is 0 -->
			<!-- In OoO cores, loads and stores can be issued whether inorder(Pentium Pro) or (OoO)out-of-order(Alpha),
			They will always try to execute out-of-order though. -->
			<param name="LSU_order" value="inorder"/>
			<param name="store_buffer_size" value="0"/>
			<!-- By default, in-order cores do not have load buffers -->
			<param name="load_buffer_size" value="0"/>	
			<!-- number of ports refer to sustain-able concurrent memory accesses --> 
			<param name="memory_ports" value="0"/>	
			<!-- max_allowed_in_flight_memo_instructions determines the # of ports of load and store buffer
			as well as the ports of Dcache which is connected to LSU -->	
			<!-- dual-pumped Dcache can be used to save the extra read/write ports -->
			<param name="RAS_size" value="0"/>						
			<!-- general stats, defines simulation periods;require total, idle, and busy cycles for sanity check  -->
			<!-- please note: if target architecture is X86, then all the instructions refer to (fused) micro-ops -->
			<stat name="total_instructions" value="0"/>
			<stat name="int_instructions" value="0"/>
			<stat name="fp_instructions" value="0"/>
			<stat name="branch_instructions" value="0"/>
			<stat name="branch_mispredictions" value="0"/>
			<stat name="load_instructions" value="0"/>
			<stat name="store_instructions" value="0"/>
			<stat name="committed_instructions" value="0"/>
			<stat name="committed_int_instructions" value="0"/>
			<stat name="committed_fp_instructions" value="0"/>
			<stat name="pipeline_duty_cycle" value="1"/><!--<=1, runtime_ipc/peak_ipc; averaged for all cores if homogeneous -->
			<!-- the following cycle stats are used for heterogeneous cores only, 
				please ignore them if homogeneous cores -->
			<stat name="total_cycles" value="2660804"/>
			<stat name="idle_cycles" value="1322906"/>
			<stat name="busy_cycles"  value="1337899"/>
			<!-- instruction buffer stats -->
			<!-- ROB stats, both RS and Phy based OoOs have ROB
			performance simulator should capture the difference on accesses,
			otherwise, McPAT has to guess based on number of committed instructions. -->
			<stat name="ROB_reads" value="0"/>
			<stat name="ROB_writes" value="0"/>
			<!-- RAT accesses -->
			<stat name="rename_reads" value="0"/> <!--lookup in renaming logic -->
			<stat name="rename_writes" value="0"/><!--update dest regs. renaming logic -->
			<stat name="fp_rename_reads" value="0"/>
			<stat name="fp_rename_writes" value="0"/>
			<!-- decode and rename stage use this, should be total ic - nop -->
			<!-- Inst window stats -->
			<stat name="inst_window_reads" value="0"/>
			<stat name="inst_window_writes" value="0"/>
			<stat name="inst_window_wakeup_accesses" value="0"/>
			<stat name="fp_inst_window_reads" value="0"/>
			<stat name="fp_inst_window_writes" value="0"/>
			<stat name="fp_inst_window_wakeup_accesses" value="0"/>
			<!--  RF accesses -->
			<stat name="int_regfile_reads" value="0"/>
			<stat name="float_regfile_reads" value="0"/>
			<stat name="int_regfile_writes" value="0"/>
			<stat name="float_regfile_writes" value="0"/>
			<!-- accesses to the working reg -->
			<stat name="function_calls" value="0"/>
			<stat name="context_switches" value="0"/>
			<!-- Number of Windows switches (number of function calls and returns)-->
			<!-- Alu stats by default, the processor has one FPU that includes the divider and 
			 multiplier. The fpu accesses should include accesses to multiplier and divider  -->
			<stat name="ialu_accesses" value="0"/>			
			<stat name="fpu_accesses" value="0"/>
			<stat name="mul_accesses" value="0"/>
			<stat name="cdb_alu_accesses" value="0"/>
			<stat name="cdb_mul_accesses" value="0"/>
			<stat name="cdb_fpu_accesses" value="0"/>
			<!-- multiple cycle accesses should be counted multiple times, 
			otherwise, McPAT can use internal counter for different floating point instructions 
			to get final accesses. But that needs detailed info for floating point inst mix -->
			<!--  currently the performance simulator should 
			make sure all the numbers are final numbers, 
			including the explicit read/write accesses, 
			and the implicit accesses such as replacements and etc.
			Future versions of McPAT may be able to reason the implicit access
			based on param and stats of last level cache
			The same rule applies to all cache access stats too!  -->
			<!-- following is AF for max power computation. 
				Do not change them, unless you understand them-->
			<stat name="IFU_duty_cycle" value="0.9"/>
			<stat name="BR_duty_cycle" value="0.72"/><!--branch-->			
			<stat name="LSU_duty_cycle" value="0.71"/>
			<stat name="MemManU_I_duty_cycle" value="0.9"/>
			<stat name="MemManU_D_duty_cycle" value="0.71"/>
			<stat name="ALU_duty_cycle" value="0.76"/>
			<!-- (.78*2+.71)/3 -->
			<stat name="MUL_duty_cycle" value="0.82"/>
			<stat name="FPU_duty_cycle" value="0.0"/>
			<stat name="ALU_cdb_duty_cycle" value="0.76"/>
			<stat name="MUL_cdb_duty_cycle" value="0.82"/>
			<stat name="FPU_cdb_duty_cycle" value="0.0"/>
		</component>
<!--***************************** Pre-Fetchers ***************************-->
        <component id="system.L30" name="L3">
            <!-- Data input pre-fetcher -->
            <!-- Capacity is in byte. Demo application requires 88 Bytes for all pre-fetchers.-->
            <param name="L3_config" value="96,2,2,1,1,1"/>
            <!-- the parameters are capacity,block_width, associativity,bank, throughput w.r.t. core clock, latency w.r.t. core clock,-->
            <param name="clockrate" value="5"/>
            <param name="ports" value="1,1,0,1"/>
            <!-- number of r, w, rw, search ports -->
            <param name="device_type" value="0"/>
            <param name="buffer_sizes" value="0, 0, 0, 0"/>
            <!-- cache controller buffer sizes: miss_buffer_size(MSHR),fill_buffer_size,prefetch_buffer_size,wb_buffer_size-->	
            <stat name="read_accesses" value="11824"/>
            <stat name="write_accesses" value="11276"/>
            <stat name="read_misses" value="1632"/>
            <stat name="write_misses" value="183"/>
            <stat name="conflicts" value="0"/>	
            <stat name="duty_cycle" value="1.0"/>	
        </component>
<!--**********************************************************************-->
<!--******************************** NOCs ********************************-->
		<component id="system.NoC0" name="noc0">
            <param name="name" value="Input-Channel"/>
			<param name="clockrate" value="5"/>
			<param name="type" value="1"/>
			<!--0:bus, 1:NoC , for bus no matter how many nodes sharing the bus
				at each time only one node can send req -->
			<param name="horizontal_nodes" value="8"/>
			<param name="vertical_nodes" value="1"/>
			<!-- It is mendatory to have at least 1 vetical/horizontal node to
			     calculate the right area if using a NOC. -->
			<param name="has_global_link" value="0"/>
			<!-- 1 has global link, 0 does not have global link -->
			<param name="link_throughput" value="1"/><!--w.r.t clock -->
			<param name="link_latency" value="1"/><!--w.r.t clock -->
			<!-- throughput >= latency -->
			<!-- Router architecture -->
			<param name="input_ports" value="8"/>
			<param name="output_ports" value="1"/>
			<!-- For bus the I/O ports should be 1 -->
			<param name="flit_bits" value="16"/>
			<!-- Virtual Channel bitwidth -->
			<param name="chip_coverage" value="0.0000001"/>
			<!-- When multiple NOC present, one NOC will cover part of the whole chip. 
				chip_coverage <=1 -->
			<param name="link_routing_over_percentage" value="0.05"/>
			<!-- Links can route over other components or occupy whole area.
				by default, 50% of the NoC global links routes over other 
				components -->
			<stat name="total_accesses" value="2660805"/>
			<!-- This is the number of total accesses within the whole network not for each router -->
			<stat name="duty_cycle" value="1.0"/>
		</component>		
		<component id="system.NoC1" name="noc1">
            <param name="name" value="First-Level"/>
			<param name="clockrate" value="5"/>
			<param name="type" value="1"/>
			<!--0:bus, 1:NoC , for bus no matter how many nodes sharing the bus
				at each time only one node can send req -->
			<param name="horizontal_nodes" value="8"/>
			<param name="vertical_nodes" value="1"/>
			<!-- It is mendatory to have at least 1 vetical/horizontal node to
			     calculate the right area if using a NOC. -->
			<param name="has_global_link" value="0"/>
			<!-- 1 has global link, 0 does not have global link -->
			<param name="link_throughput" value="1"/><!--w.r.t clock -->
			<param name="link_latency" value="1"/><!--w.r.t clock -->
			<!-- throughput >= latency -->
			<!-- Router architecture -->
			<param name="input_ports" value="4"/>
			<param name="output_ports" value="1"/>
			<!-- For bus the I/O ports should be 1 -->
			<param name="flit_bits" value="16"/>
			<!-- Virtual Channel bitwidth -->
			<param name="chip_coverage" value="0.000001"/>
			<!-- When multiple NOC present, one NOC will cover part of the whole chip. 
				chip_coverage <=1 -->
			<param name="link_routing_over_percentage" value="0.05"/>
			<!-- Links can route over other components or occupy whole area.
				by default, 50% of the NoC global links routes over other 
				components -->
			<stat name="total_accesses" value="2660805"/>
			<!-- This is the number of total accesses within the whole network not for each router -->
			<stat name="duty_cycle" value="1.0"/>
		</component>		
		<component id="system.NoC2" name="noc2">
            <param name="name" value="Second-Level"/>
			<param name="clockrate" value="5"/>
			<param name="type" value="1"/>
			<!--0:bus, 1:NoC , for bus no matter how many nodes sharing the bus
				at each time only one node can send req -->
			<param name="horizontal_nodes" value="8"/>
			<param name="vertical_nodes" value="1"/>
			<!-- It is mendatory to have at least 1 vetical/horizontal node to
			     calculate the right area if using a NOC. -->
			<param name="has_global_link" value="0"/>
			<!-- 1 has global link, 0 does not have global link -->
			<param name="link_throughput" value="1"/><!--w.r.t clock -->
			<param name="link_latency" value="1"/><!--w.r.t clock -->
			<!-- throughput >= latency -->
			<!-- Router architecture -->
			<param name="input_ports" value="4"/>
			<param name="output_ports" value="1"/>
			<!-- For bus the I/O ports should be 1 -->
			<param name="flit_bits" value="16"/>
			<!-- Virtual Channel bitwidth -->
			<param name="chip_coverage" value="0.000001"/>
			<!-- When multiple NOC present, one NOC will cover part of the whole chip. 
				chip_coverage <=1 -->
			<param name="link_routing_over_percentage" value="0.05"/>
			<!-- Links can route over other components or occupy whole area.
				by default, 50% of the NoC global links routes over other 
				components -->
			<stat name="total_accesses" value="2660805"/>
			<!-- This is the number of total accesses within the whole network not for each router -->
			<stat name="duty_cycle" value="1.0"/>
		</component>		
		<component id="system.NoC3" name="noc3">
            <param name="name" value="Third-Level"/>
			<param name="clockrate" value="5"/>
			<param name="type" value="1"/>
			<!--0:bus, 1:NoC , for bus no matter how many nodes sharing the bus
				at each time only one node can send req -->
			<param name="horizontal_nodes" value="8"/>
			<param name="vertical_nodes" value="1"/>
			<!-- It is mendatory to have at least 1 vetical/horizontal node to
			     calculate the right area if using a NOC. -->
			<param name="has_global_link" value="0"/>
			<!-- 1 has global link, 0 does not have global link -->
			<param name="link_throughput" value="1"/><!--w.r.t clock -->
			<param name="link_latency" value="1"/><!--w.r.t clock -->
			<!-- throughput >= latency -->
			<!-- Router architecture -->
			<param name="input_ports" value="4"/>
			<param name="output_ports" value="1"/>
			<!-- For bus the I/O ports should be 1 -->
			<param name="flit_bits" value="16"/>
			<!-- Virtual Channel bitwidth -->
			<param name="chip_coverage" value="0.000001"/>
			<!-- When multiple NOC present, one NOC will cover part of the whole chip. 
				chip_coverage <=1 -->
			<param name="link_routing_over_percentage" value="0.05"/>
			<!-- Links can route over other components or occupy whole area.
				by default, 50% of the NoC global links routes over other 
				components -->
			<stat name="total_accesses" value="2660805"/>
			<!-- This is the number of total accesses within the whole network not for each router -->
			<stat name="duty_cycle" value="1.0"/>
		</component>		
<!--**********************************************************************-->
		<component id="system.mc" name="mc">
			<!-- Memory controllers are for DDR(2,3...) DIMMs -->
			<!-- current version of McPAT uses published values for base parameters of memory controller
			improvements on MC will be added in later versions. -->
			<param name="type" value="1"/> <!-- 1: low power; 0 high performance -->
			<param name="mc_clock" value="5"/><!--MHz-->
			<param name="peak_transfer_rate" value="0.625"/><!--MB/S-->
			<param name="block_size" value="1"/><!--(B) the block size of last level cache, which is the unit for one memory burst transfer -->
			<param name="number_mcs" value="1"/>
			<!-- current McPAT only supports homogeneous memory controllers -->
			<param name="memory_channels_per_mc" value="1"/>
			<param name="number_ranks" value="0"/>
			<!-- # of ranks of each channel-->
			<param name="req_window_size_per_channel" value="32"/>
			<param name="IO_buffer_size_per_channel" value="32"/>
			<param name="databus_width" value="16"/>
			<param name="addressbus_width" value="16"/>
			<!-- McPAT will add the control bus width to the address bus width automatically -->
			<stat name="memory_accesses" value="146160"/>
			<stat name="memory_reads" value="123096"/>
			<stat name="memory_writes" value="23064"/>
			<param name="withPHY" value="1"/>
			<!-- McPAT does not track individual mc, instead, it takes the total accesses and calculate 
			the average power per MC or per channel. This is sufficient for most application. 
			Further trackdown can be easily added in later versions. -->  			
		</component>
<!--**********************************************************************-->
<!--**********************************************************************-->
		<component id="system.niu" name="niu">
			<!-- On chip 10Gb Ethernet NIC, including XAUI Phy and MAC controller  -->
			<!-- For a minimum IP packet size of 84B at 10Gb/s, a new packet arrives every 67.2ns. 
				 the low bound of clock rate of a 10Gb MAC is 150Mhz -->
			<param name="type" value="1"/> <!-- 1: low power; 0 high performance -->
			<param name="clockrate" value="350"/>
			<param name="number_units" value="0"/> <!-- unlike PCIe and memory controllers, each Ethernet controller only have one port -->
			<stat name="duty_cycle" value="1.0"/> <!-- achievable max load <= 1.0 -->
			<stat name="total_load_perc" value="0.7"/> <!-- ratio of total achieved load to total achieve-able bandwidth  -->
			<!-- McPAT does not track individual nic, instead, it takes the total accesses and calculate 
			the average power per nic or per channel. This is sufficient for most application. -->  			
		</component>
<!--**********************************************************************-->
		<component id="system.pcie" name="pcie">
			<!-- On chip PCIe controller, including Phy-->
			<!-- For a minimum PCIe packet size of 84B at 8Gb/s per lane (PCIe 3.0), a new packet arrives every 84ns. 
				 the low bound of clock rate of a PCIe per lane logic is 120Mhz -->
			<param name="type" value="1"/> <!-- 1: low power; 0 high performance -->
			<param name="withPHY" value="1"/>
			<param name="clockrate" value="350"/>
			<param name="number_units" value="0"/>
			<param name="num_channels" value="8"/> <!-- 2 ,4 ,8 ,16 ,32 -->
			<stat name="duty_cycle" value="1.0"/> <!-- achievable max load <= 1.0 -->
			<stat name="total_load_perc" value="0.7"/> <!-- Percentage of total achieved load to total achieve-able bandwidth  -->
			<!-- McPAT does not track individual pcie controllers, instead, it takes the total accesses and calculate 
			the average power per pcie controller or per channel. This is sufficient for most application. -->  			
		</component>
<!--**********************************************************************-->
		<component id="system.flashc" name="flashc">
		    <param name="number_flashcs" value="0"/>
			<param name="type" value="1"/> <!-- 1: low power; 0 high performance -->
            <param name="withPHY" value="0"/>
			<param name="peak_transfer_rate" value="0.625"/><!--Per controller sustain-able peak rate MB/S -->
			<stat name="duty_cycle" value="1.0"/> <!-- achievable max load <= 1.0 -->
			<stat name="total_load_perc" value="0.7"/> <!-- Percentage of total achieved load to total achieve-able bandwidth  -->
			<!-- McPAT does not track individual flash controller, instead, it takes the total accesses and calculate 
			the average power per fc or per channel. This is sufficient for most application -->  			
		</component>
<!--**********************************************************************-->
	</component>
</component>
